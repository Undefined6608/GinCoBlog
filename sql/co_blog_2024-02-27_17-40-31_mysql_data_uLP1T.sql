-- MySQL dump 10.13  Distrib 5.7.44, for Linux (x86_64)
--
-- Host: localhost    Database: co_blog
-- ------------------------------------------------------
-- Server version	5.7.44-log

/*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */;
/*!40101 SET @OLD_CHARACTER_SET_RESULTS=@@CHARACTER_SET_RESULTS */;
/*!40101 SET @OLD_COLLATION_CONNECTION=@@COLLATION_CONNECTION */;
/*!40101 SET NAMES utf8mb4 */;
/*!40103 SET @OLD_TIME_ZONE=@@TIME_ZONE */;
/*!40103 SET TIME_ZONE='+00:00' */;
/*!40014 SET @OLD_UNIQUE_CHECKS=@@UNIQUE_CHECKS, UNIQUE_CHECKS=0 */;
/*!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0 */;
/*!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE='NO_AUTO_VALUE_ON_ZERO' */;
/*!40111 SET @OLD_SQL_NOTES=@@SQL_NOTES, SQL_NOTES=0 */;

--
-- Table structure for table `article`
--

DROP TABLE IF EXISTS `article`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `article` (
  `id` int(10) unsigned NOT NULL AUTO_INCREMENT,
  `type_id` int(10) unsigned NOT NULL,
  `user_id` int(10) unsigned NOT NULL,
  `title` varchar(191) NOT NULL,
  `context` longtext NOT NULL,
  `article_visible` tinyint(1) NOT NULL DEFAULT '1',
  `read` int(10) unsigned NOT NULL DEFAULT '0',
  `create_time` datetime DEFAULT NULL,
  `icon` longtext NOT NULL,
  PRIMARY KEY (`id`),
  UNIQUE KEY `title` (`title`)
) ENGINE=InnoDB AUTO_INCREMENT=61 DEFAULT CHARSET=utf8mb4;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `article`
--

LOCK TABLES `article` WRITE;
/*!40000 ALTER TABLE `article` DISABLE KEYS */;
INSERT INTO `article` VALUES (58,27,1,'Co-Blog 的 Gin 框架后端开发日志','# 1 创建数据库\n表结构如下图\n![](http://137.175.84.209:88/article/765f22bd-2ae6-41f1-9d04-765955cde6bc.png)\n\n# 2 创建 GitGub 项目仓库\n在 GitHub 上创建 `GinCoBlog`仓库,并将其`clone`到本地\n# 3 初始化项目\n在`clone`下来的目录下创建：\n> - config // 配置文件所在目录\n> - controller // 控制器所在目录\n> - entity // 数据库实体类所在目录\n> - logs // 运行日志所在目录\n> - middleware // 中间件所在目录\n> - model // 数据库连接所在目录\n> - request // 参数实体类所在目录\n> - router // 路由所在目录\n> - temp // 缓存文件\n> - utils // 工具所在目录\n> - .gitignore // git 不上传的文件列表\n> - Application.yaml // 项目常量定义列表\n> - main.go // 项目主入口\n\n## 3.1 加载依赖\n```bash\n## 加载 Gin 框架\ngo get -u github.com/gin-gonic/gin\n## 加载 bcrypt 依赖\ngo get golang.org/x/crypto/bcrypt\n## token依赖\ngo get github.com/dgrijalva/jwt-go\n## 跨域依赖\ngo get github.com/gin-contrib/cors\n## 日志依赖\ngo get github.com/sirupsen/logrus\n## 邮箱依赖\ngo get gopkg.in/gomail.v2\n## yaml依赖\ngo get gopkg.in/yaml.v2\n## mysql驱动\ngo get gorm.io/driver/mysql\n## 数据库依赖\ngo get gorm.io/gorm\n## redis 驱动\ngo get github.com/redis/go-redis/v9\n## UUID 生成器\ngo get -u github.com/satori/go.uuid\n```\n## 3.2 编写项目主入口\n在`main.go`中编写\n```go\n/**  \n * @projectName:    GinCoBlog \n * @package:        GinCoBlog \n * @className:      main \n * @author:     张杰  \n * @description:  TODO  \n * @date:    2023/10/4 9:23 \n * @version:    1.0 \n */\npackage main  \n  \nimport (  \n   \"github.com/gin-gonic/gin\"  \n   \"net/http\")  \n  \nfunc main() {  \n   router := gin.Default()  \n   router.GET(\"/\", func(c *gin.Context) {  \n      c.JSON(http.StatusOK, \"HelloWorld!\")  \n   })  \n   err := router.Run(\":4001\")  \n   if err != nil {  \n      panic(\"项目启动失败!\")  \n      return  \n   }  \n}\n```\n运行：\n```bash\ngo run main.go\n```\n测试：\n> 在浏览器输入 `127.0.0.1:4001`\n>\n> ![](http://137.175.84.209:88/article/c0beac44-59bb-42d3-b16f-ae3efe2be38e.png)\n\n\n## 3.3 编写项目配置文件\n在 `Application.yaml`中\n```yaml\n# 项目端口号  \nport: 4001\n```\n在 `config` 目录下创建 `ConfigDefault.go`\n```go\npackage config  \n  \nimport (  \n   \"gopkg.in/yaml.v2\"  \n   \"os\")  \n  \n// Config 配置 yaml 结构  \ntype Config struct {  \n   // 端口号  \n   Port string `yaml:\"port\"`  \n}  \n  \n// Default /** 获取 yaml 配置  \nfunc Default() Config {  \n   // 实例化配置对象  \n   var configObj Config  \n   // 读取配置文件  \n   yamlFil, err := os.ReadFile(\"Application.yaml\")  \n   // 读取失败  \n   if err != nil {  \n      panic(err)  \n   }  \n   // 将读到的文件解析为配置对象  \n   err = yaml.Unmarshal(yamlFil, &configObj)  \n   // 解析失败  \n   if err != nil {  \n      panic(err)  \n   }  \n   // 抛出配置文件对象  \n   return configObj  \n}\n```\n在 `main.go` 下：\n```go\n/**  \n * @projectName:    GinCoBlog * \n * @package:        GinCoBlog * \n * @className:      main * @author:     张杰  \n * @description:  TODO  \n * @date:    2023/10/4 9:23 * \n * @version:    1.0 *\n */\npackage main  \n// 引入相关依赖  \nimport (  \n   \"GinCoBlog/config\"  \n   \"github.com/gin-gonic/gin\"   \"net/http\")  \n// 项目主方法  \nfunc main() {  \n   // 获取项目路由  \n   router := gin.Default()  \n   // 编写项目基础接口  \n   router.GET(\"/\", func(c *gin.Context) {  \n      c.JSON(http.StatusOK, \"HelloWorld!\")  \n   })  \n   // 开启端口监听  \n   err := router.Run(\":\" + config.Default().Port)  \n   // 开启监听失败  \n   if err != nil {  \n      // 写入日志  \n      panic(\"项目启动失败!\")  \n      return  \n   }  \n}\n```\n运行：\n```bash\ngo run main.go\n```\n测试：\n> 在浏览器输入 `127.0.0.1:4001`\n> ![](http://137.175.84.209:88/article/c9bc1a8d-843c-494f-bbfa-5600de3b49f0.png)\n\n## 3.4 配置基础中间件\n### 3.4.1 配置日志中间件\n在 `Application.yaml` 中添加\n```yaml\n# 日志配置  \nlog_config:  \n  # 日志存储位置  \n  path: \'logs/\'  \n  # 日志名称  \n  name: \'gin.log\'\n```\n\n在 `config/ConfigDefalult.go`中添加\n```go\n// Config 配置 yaml 结构  \ntype Config struct {  \n   // 端口号  \n   Port string `yaml:\"port\"`  \n   // 数据库配置  \n   DataBase struct {  \n      Host     string `yaml:\"host\"`  \n      Port     string `yaml:\"port\"`  \n      UserName string `yaml:\"user_name\"`  \n      Password string `yaml:\"password\"`  \n      Schema   string `yaml:\"schema\"`  \n   } `yaml:\"data_base\"`  \n   // 日志配置  \n   LogConfig struct {  \n      Path string `yaml:\"path\"` // 日志存放路径  \n      Name string `yaml:\"name\"` // 日志名称  \n   } `yaml:\"log_config\"`  \n}\n\n// LogFilePath /**日志存放地址  \nvar LogFilePath = Default().LogConfig.Path  \n  \n// LogFileName /**日志文件名  \nvar LogFileName = Default().LogConfig.Name\n```\n\n在 `middleware` 目录下创建 `LoggerMiddleware.go`\n```go\npackage middleware  \n  \nimport (  \n   \"GinCoBlog/config\"  \n   \"fmt\"   \"github.com/gin-gonic/gin\"   \"github.com/sirupsen/logrus\"   \"os\"   \"path\"   \"time\")  \n  \n// LoggerToFile 日志记录到文件  \nfunc LoggerToFile() gin.HandlerFunc {  \n  \n   logFilePath := config.LogFilePath  \n   logFileName := config.LogFileName  \n  \n   //日志文件  \n   fileName := path.Join(logFilePath, logFileName)  \n  \n   //写入文件  \n   src, err := os.OpenFile(fileName, os.O_APPEND|os.O_WRONLY|os.O_CREATE, os.ModeAppend)  \n   if err != nil {  \n      logrus.Error(\"err\", err)\n   }  \n  \n   //实例化  \n   logger := logrus.New()  \n  \n   //设置输出  \n   logger.Out = src  \n  \n   //设置日志级别  \n   logger.SetLevel(logrus.DebugLevel)  \n  \n   //设置日志格式  \n   logger.SetFormatter(&logrus.TextFormatter{})  \n  \n   return func(c *gin.Context) {  \n      // 开始时间  \n      startTime := time.Now()  \n  \n      // 处理请求  \n      c.Next()  \n  \n      // 结束时间  \n      endTime := time.Now()  \n  \n      // 执行时间  \n      latencyTime := endTime.Sub(startTime)  \n  \n      // 请求方式  \n      reqMethod := c.Request.Method  \n  \n      // 请求路由  \n      reqUri := c.Request.RequestURI  \n  \n      // 状态码  \n      statusCode := c.Writer.Status()  \n  \n      // 请求IP  \n      clientIP := c.ClientIP()  \n  \n      // 日志格式  \n      logger.Infof(\"| %3d | %13v | %15s | %s | %s |\",  \n         statusCode,  \n         latencyTime,  \n         clientIP,  \n         reqMethod,  \n         reqUri,  \n      )  \n   }  \n}  \n  \n// LoggerToMongo 日志记录到 MongoDBfunc LoggerToMongo() gin.HandlerFunc {  \n   return func(c *gin.Context) {  \n  \n   }}  \n  \n// LoggerToES 日志记录到 ESfunc LoggerToES() gin.HandlerFunc {  \n   return func(c *gin.Context) {  \n  \n   }}  \n  \n// LoggerToMQ 日志记录到 MQfunc LoggerToMQ() gin.HandlerFunc {  \n   return func(c *gin.Context) {  \n  \n   }\n}\n```\n\n在 `main.go` 中挂载此中间件\n```go\n// 挂载中间件  \nrouter.Use(gin.Logger(), gin.Recovery(), middleware.LoggerToFile())\n```\n\n### 3.4.2 挂载代理中间件\n在 `main.go` 中添加\n```go\n// 加载代理中间件  \nerr := router.SetTrustedProxies([]string{\"192.168.1.0/24\"})  \nif err != nil {  \n   fmt.Println(\"代理失败！\")  \n   return  \n}\n```\n### 3.4.3 配置跨域中间件\n在 `Application.yaml` 中\n```yaml\n# 跨域IP  \ncors:  \n  ip:  \n    - \'http://127.0.0.1\'  \n    - \'http://39.101.72.168\'  \n    - \'http://localhost\'  \n  methods:  \n    - \'GET\'  \n    - \'POST\'  \n    - \'PUT\'  \n    - \'DELETE\'\n```\n在 `config/ConfigDefault.go` 中\n```go\n// Config 配置 yaml 结构  \ntype Config struct {  \n   // 端口号  \n   Port string `yaml:\"port\"`  \n   // 数据库配置  \n   DataBase struct {  \n      Host     string `yaml:\"host\"`  \n      Port     string `yaml:\"port\"`  \n      UserName string `yaml:\"user_name\"`  \n      Password string `yaml:\"password\"`  \n      Schema   string `yaml:\"schema\"`  \n   } `yaml:\"data_base\"`  \n   // 日志配置  \n   LogConfig struct {  \n      Path string `yaml:\"path\"`  \n      Name string `yaml:\"name\"`  \n   } `yaml:\"log_config\"`  \n   // 正则配置  \n   Regular struct {  \n      Phone string `yaml:\"phone\"`  \n      Email string `yaml:\"email\"`  \n   } `yaml:\"regular\"`  \n   // 邮箱配置  \n   EmailConfig struct {  \n      EmailAddress string `yaml:\"email_address\"`  \n      EmailName    string `yaml:\"email_name\"`  \n      Password     string `yaml:\"password\"`  \n      SmtpServer   string `yaml:\"smtp_server\"`  \n      SmtpPort     int    `yaml:\"smtp_port\"`  \n   } `yaml:\"email_config\"`  \n   // redis 配置  \n   RedisConfig struct {  \n      Host     string `yaml:\"host\"`  \n      Port     string `yaml:\"port\"`  \n      Password string `yaml:\"password\"`  \n      DB       int    `yaml:\"db\"`  \n   } `yaml:\"redis_config\"`  \n   // 加密配置  \n   Encryption struct {  \n      // 私钥  \n      PrivateKey struct {  \n         Password string `yaml:\"password\"`  \n      } `yaml:\"private_key\"`  \n      // 盐值  \n      Salt struct {  \n         Password int `yaml:\"password\"`  \n      } `yaml:\"salt\"`  \n   } `yaml:\"encryption\"`  \n   // token 配置  \n   Token struct {  \n      PrivateKey string `yaml:\"private_key\"`  \n   } `yaml:\"token\"`  \n   // 绕过中间件验证的地址  \n   NotVerifyUrl []string `yaml:\"not_verify_url\"`  \n   // 跨域中间件验证地址  \n   Cors struct {  \n      Ip      []string `yaml:\"ip\"`  \n      Methods []string `yaml:\"methods\"`  \n   } `yaml:\"cors\"`  \n}\n\n// Cors 跨域  \nvar Cors = Default().Cors\n```\n\n在 `middleware` 目录下创建 `CorsMiddleware.go` 下\n```go\npackage middleware  \n  \nimport (  \n   \"GinCoBlog/config\"  \n   \"github.com/gin-contrib/cors\"   \"github.com/gin-gonic/gin\")  \n  \n// CorsMiddleware 跨域中间件  \nfunc CorsMiddleware() gin.HandlerFunc {  \n   corsConfig := cors.DefaultConfig()  \n   allowAccess := config.Cors.Ip  \n   corsConfig.AllowOrigins = allowAccess // 允许访问的域名  \n   corsConfig.AllowMethods = config.Cors.Methods  \n  \n   return cors.New(corsConfig)  \n}\n```\n\n在 `main.go` 中\n```go\n// 挂载中间件  \nrouter.Use(gin.Logger(), gin.Recovery(), middleware.CorsMiddleware(), middleware.LoggerToFile(), middleware.JwtVerifyMiddle())\n```\n\n### 3.4.4 编写Token验证中间件\n在 `Application.yaml` 中\n```yaml\n# 不验证的接口地址  \nnot_verify_url:  \n  - \'/api/user/phoneOccupy\'  \n  - \'/api/user/emailOccupy\'  \n  - \'/api/user/register\'  \n  - \'/api/user/phoneLogin\'  \n  - \'/api/user/emailLogin\'  \n  - \'/api/user/sendEmailCode\'  \n  - \'/api/user/forgotPassword\'\n```\n\n在 `config/ConfigDefault.go` 中\n```go\n// Config 配置 yaml 结构  \ntype Config struct {  \n   // 端口号  \n   Port string `yaml:\"port\"`  \n   // 数据库配置  \n   DataBase struct {  \n      Host     string `yaml:\"host\"`  \n      Port     string `yaml:\"port\"`  \n      UserName string `yaml:\"user_name\"`  \n      Password string `yaml:\"password\"`  \n      Schema   string `yaml:\"schema\"`  \n   } `yaml:\"data_base\"`  \n   // 日志配置  \n   LogConfig struct {  \n      Path string `yaml:\"path\"`  \n      Name string `yaml:\"name\"`  \n   } `yaml:\"log_config\"`  \n   // 正则配置  \n   Regular struct {  \n      Phone string `yaml:\"phone\"`  \n      Email string `yaml:\"email\"`  \n   } `yaml:\"regular\"`  \n   // 邮箱配置  \n   EmailConfig struct {  \n      EmailAddress string `yaml:\"email_address\"`  \n      EmailName    string `yaml:\"email_name\"`  \n      Password     string `yaml:\"password\"`  \n      SmtpServer   string `yaml:\"smtp_server\"`  \n      SmtpPort     int    `yaml:\"smtp_port\"`  \n   } `yaml:\"email_config\"`  \n   // redis 配置  \n   RedisConfig struct {  \n      Host     string `yaml:\"host\"`  \n      Port     string `yaml:\"port\"`  \n      Password string `yaml:\"password\"`  \n      DB       int    `yaml:\"db\"`  \n   } `yaml:\"redis_config\"`  \n   // 加密配置  \n   Encryption struct {  \n      // 私钥  \n      PrivateKey struct {  \n         Password string `yaml:\"password\"`  \n      } `yaml:\"private_key\"`  \n      // 盐值  \n      Salt struct {  \n         Password int `yaml:\"password\"`  \n      } `yaml:\"salt\"`  \n   } `yaml:\"encryption\"`  \n   // token 配置  \n   Token struct {  \n      PrivateKey string `yaml:\"private_key\"`  \n   } `yaml:\"token\"`  \n   // 绕过中间件验证的地址  \n   NotVerifyUrl []string `yaml:\"not_verify_url\"`  \n}\n```\n\n在 `utils/index.go` 下\n```go\n// IsContainArr /**Token URL过滤  \nfunc IsContainArr(noVerify []string, requestUrl string) bool {  \n   for _, str := range noVerify {  \n      if str == requestUrl {  \n         return true  \n      }  \n   }  \n   return false  \n}\n```\n\n在 `service/UserService.go` 下\n```go\n// VerUserByToken 通过Token查找用户  \nfunc VerUserByToken(token string) (string, error) {  \n   // 验证数据库中是否存有此token  \n   user, err := RedisClient().Get(ctx, token).Result()  \n   return user, err  \n}\n```\n\n在 `middleware` 目录下创建 `TokenMiddleware.go`\n```go\npackage middleware  \n  \nimport (  \n   \"GinCoBlog/config\"  \n   \"GinCoBlog/request\"   \"GinCoBlog/service\"   \"GinCoBlog/utils\"   \"github.com/dgrijalva/jwt-go\"   \"github.com/gin-gonic/gin\"   \"log\")  \n  \n// JwtVerifyMiddle /**验证token  \nfunc JwtVerifyMiddle() gin.HandlerFunc {  \n   return func(c *gin.Context) {  \n      //过滤是否验证token  \n      if utils.IsContainArr(config.NotVerifyUrl, c.Request.URL.Path) {  \n         return  \n      }  \n      token := c.GetHeader(\"Authorization\")  \n      if token == \"\" {  \n         log.Println(\"\")  \n         utils.AuthorizationResult(c, \"权限验证失败,无法访问系统资源！\")  \n         // 终止请求  \n         c.Abort()  \n         return  \n      }  \n      // 判断是否错误  \n      claims := parseToken(c, token)  \n      //验证token，并存储在请求中  \n      c.Set(\"user\", claims)  \n   }  \n}  \n  \n// 解析Token  \nfunc parseToken(c *gin.Context, tokenString string) *request.TokenParams {  \n   // 验证数据库中是否存有此token  \n   user, err := service.VerUserByToken(tokenString)  \n   // 没查到  \n   if err != nil || user == \"\" {  \n      utils.AuthorizationResult(c, \"权限验证失败,无法访问系统资源！\")  \n      c.Abort()  \n      return nil  \n   }  \n   //解析token  \n   token, err := jwt.ParseWithClaims(tokenString, &request.TokenParams{}, func(token *jwt.Token) (interface{}, error) {  \n      return []byte(config.TokenPrivateKey), nil  \n   })  \n   // 解析成功  \n   if err != nil {  \n      utils.AuthorizationResult(c, \"权限验证失败,无法访问系统资源！\")  \n      c.Abort()  \n      return nil  \n   }  \n   // 将Token内存的数据转化为 token.Claims   claims, ok := token.Claims.(*request.TokenParams)  \n   // 转化失败  \n   if !ok {  \n      utils.AuthorizationResult(c, \"登录失效！\")  \n      c.Abort()  \n      return nil  \n   }  \n   // 抛出数据  \n   return claims  \n}\n```\n# 4 正式编写\n## 4.1 封装路由\n在 `router` 目录下新建 `UserRouter.go`\n```go\npackage router  \n  \nimport (  \n   \"github.com/gin-gonic/gin\"  \n   \"net/http\")  \n  \n// UserRouter 定义用户路由（二级）\nfunc UserRouter(router *gin.RouterGroup) {  \n   router.GET(\"/\", func(c *gin.Context) {  \n      c.JSON(http.StatusOK, \"HelloUser!\")  \n   })  \n}\n```\n在 `router` 目录下新建 `index.go`\n```go\npackage router  \n  \nimport \"github.com/gin-gonic/gin\"  \n  \n// SetupRouterGroup 项目主路由（一级）  \nfunc SetupRouterGroup(router *gin.RouterGroup) {  \n   // 调取用户路由\n   UserRouter(router.Group(\"/user\"))  \n}\n```\n在 `main.go` 中\n```go\n/**  \n * @projectName:    GinCoBlog \n * @package:        GinCoBlog \n * @className:      main \n * @author:     张杰  \n * @description:  TODO  \n * @date:    2023/10/4 9:23 * @version:    1.0 \n */\npackage main  \n  \n// 引入相关依赖  \nimport (  \n   \"GinCoBlog/config\"  \n   routes \"GinCoBlog/router\"  \n   \"github.com/gin-gonic/gin\"   \"net/http\")  \n  \n// 项目主方法  \nfunc main() {  \n   // 获取项目路由  \n   router := gin.Default()  \n   // 编写项目基础接口  \n   router.GET(\"/\", func(c *gin.Context) {  \n      c.JSON(http.StatusOK, \"HelloWorld!\")  \n   })  \n   // 调用项目主路由  \n   routes.SetupRouterGroup(router.Group(\"/api\"))  \n   // 开启端口监听  \n   err := router.Run(\":\" + config.Default().Port)  \n   // 开启监听失败  \n   if err != nil {  \n      // 写入日志  \n      panic(\"项目启动失败!\")  \n      return  \n   }  \n}\n```\n## 4.2 提取控制器\n在 `controller` 目录下创建 `UserController.go`\n```go\npackage controller  \n  \nimport (  \n   \"github.com/gin-gonic/gin\"  \n   \"net/http\")  \n  \n// HelloUser 测试  \nfunc HelloUser(c *gin.Context) {  \n   // 返回数据  \n   c.JSON(http.StatusOK, gin.H{\"msg\": \"HelloUser!\"})  \n}\n```\n修改 `router/UserRouter.go`\n```go\npackage routes  \n  \nimport (  \n   \"GinCoBlog/controller\"  \n   \"github.com/gin-gonic/gin\")  \n  \n// UserRouter 定义用户路由（二级）  \nfunc UserRouter(router *gin.RouterGroup) {  \n   // 用户相关接口  \n   router.GET(\"/\", controller.HelloUser)  \n}\n```\n运行\n```bash\ngo run main.go\n```\n测试\n> 在浏览器输入 `http://localhost:4001/api/user`\n> ![](http://137.175.84.209:88/article/219ac7a5-4ea2-4256-81a6-c89eff1181c0.png)\n\n\n## 4.3 编写数据库实体类\n> 1. SysUser\n> 2. ArticleType\n> 3. Article\n> 4. ArticleComments\n> 5. FeedBack\n\n`entity/SysUser.go`\n```go\npackage entity  \n  \n// SysUser 用户表结构  \ntype SysUser struct {  \n   UID           uint32 `json:\"uid\" gorm:\"primaryKey;autoIncrement;not null\"`                           // 主键 用户ID  \n   UserName      string `json:\"user_name\"`                                                              // 用户名  \n   Phone         string `json:\"phone\" gorm:\"not null;unique;size:11\"`                                   // 电话号码 不允许为空 唯一  \n   HeadSculpture string `json:\"head_sculpture\" gorm:\"default:\'http://39.101.72.168:81/image/icon.jpg\'\"` // 头像 默认值  \n   Password      string `json:\"password\" gorm:\"type:text;not null\"`                                     // 密码 默认值  \n   Email         string `json:\"email\" gorm:\"not null;unique\"`                                           // 邮箱 不允许为空 唯一  \n   Available     bool   `json:\"available\" gorm:\"not null;default:0\"`                                    // 是否注销 不允许为空 默认值  \n   Limit         uint8  `json:\"limit\" gorm:\"not null;default:2\"`                                        // 权限 不允许为空 默认值  \n   Integral      uint32 `json:\"integral\" gorm:\"not null;default:0\"`                                     //用户积分  \n   Member        uint8  `json:\"member\" gorm:\"not null;default:2\"`                                       // 会员: 0 超级会员、1 会员、2 非会员  \n   UUID          string `json:\"uuid\" gorm:\"not null;type:uuid;default:uuid_generate_v4()\"`              // 用户身份  \n}  \n  \n// TableName /** 复写默认方法，设置表名  \nfunc (SysUser) TableName() string {  \n   return \"sys_user\"  \n}\n```\n\n`entity/ArticleType.go`\n```go\npackage entity  \n  \n// ArticleType 文章类型表  \ntype ArticleType struct {  \n   ID          uint32 `json:\"id\" gorm:\"primaryKey;autoIncrement;not null\"` // 文章类型ID  \n   RootID      uint32 `json:\"root_id\" gorm:\"not null\"`                     // 文章类型根ID  \n   TypeName    string `json:\"type_name\" gorm:\"not null;unique\"`            // 文章类型名称  \n   TypeVisible bool   `json:\"type_visible\" gorm:\"not null;default:1\"`      // 类型是否显示  \n   Order       uint8  `json:\"order\" gorm:\"not null;unique\"`                // 排序  \n   Picture     string `json:\"picture\" gorm:\"not null\"`                     // 类型图片  \n   AddStatus   bool   `json:\"edit_status\" gorm:\"not null; default:1\"`      // 是否可加入文章  \n}  \n  \n// TableName /** 复写默认方法，设置表名  \nfunc (ArticleType) TableName() string {  \n   return \"article_type\"  \n}\n```\n\n`entity/Article.go`\n```go\npackage entity  \n  \n// Article 用户表结构  \ntype Article struct {  \n   ID             int32  `json:\"id\" gorm:\"primaryKey;autoIncrement;not null\"` // 文章ID  \n   TypeId         int32  `json:\"typeId\" gorm:\"not null\"`                      // 文章类型ID  \n   UserId         int32  `json:\"userId\" gorm:\"not null\"`                      // 用户ID  \n   Title          string `json:\"title\" gorm:\"not null;unique\"`                // 文章标题  \n   Context        string `json:\"context\" gorm:\"not null\"`                     // 文章内容  \n   ArticleVisible bool   `json:\"article_visible\" gorm:\"not null;default:1\"`   // 文章是否显示  \n   Read           int32  `json:\"read\" gorm:\"not null;default:0\"`              // 阅读量  \n   Date           string `json:\"date\" gorm:\"not null\"`                        // 上传时间  \n   Icon           string `json:\"icon\" gorm:\"not null\"`                        // 文章图像  \n}  \n  \n// TableName /** 复写默认方法，设置表名  \nfunc (Article) TableName() string {  \n   return \"article\"  \n}\n```\n\n`entity/ArticleCommits.go`\n```go\npackage entity  \n  \n// ArticleComments 文章评论表  \ntype ArticleComments struct {  \n   ID        uint32 `json:\"id\" gorm:\"primaryKey;autoIncrement;not null\"` // 评论ID  \n   ArticleID uint32 `json:\"article\" gorm:\"not null\"`                     // 文章ID  \n   UserID    uint32 `json:\"user_id\" gorm:\"not null\"`                     // 用户ID  \n   Context   string `json:\"context\" gorm:\"not null\"`                     // 评论内容  \n}  \n  \n// TableName /** 复写默认方法，设置表名  \nfunc (ArticleComments) TableName() string {  \n   return \"article_comments\"  \n}\n```\n\n`entity/FeedBack.go`\n```go\npackage entity  \n  \n// FeedBack 反馈表  \ntype FeedBack struct {  \n   ID      uint32 `json:\"id\" gorm:\"primaryKey;autoIncrement;not null\"` // 评论ID  \n   UserID  uint32 `json:\"user_id\" gorm:\"not null\"`                     // 用户ID  \n   Context string `json:\"context\" gorm:\"not null\"`                     // 反馈内容  \n}  \n  \n// TableName /** 复写默认方法，设置表名  \nfunc (FeedBack) TableName() string {  \n   return \"feed_back\"  \n}\n```\n## 4.4 编写数据库配置\n在 `Application.yaml`下添加\n```yaml\n# 服务器配置  \ndataBase:  \n  # 服务器地址  \n  host: \'localhost\'  \n  # 服务器端口  \n  port: \'3306\'  \n  # 用户名  \n  userName: \'root\'  \n  # 密码  \n  password: \'555555\'  \n  # 数据库名  \n  schema: \'gin_co_blog\'\n# redis  \nredis_config:  \n  host: \'127.0.0.1\'  \n  port: \'6379\'  \n  password: \'\'  \n  db: 0\n```\n在 `config/ConfigDefault.go` 下修改\n```go\n// Config 配置 yaml 结构  \ntype Config struct {  \n   // 端口号  \n   Port     string `yaml:\"port\"`  \n   DataBase struct {  \n      Host     string `yaml:\"host\"`  \n      Port     string `yaml:\"port\"`  \n      UserName string `yaml:\"user_name\"`  \n      Password string `yaml:\"password\"`  \n      Schema   string `yaml:\"schema\"`  \n   } `yaml:\"data_base\"`\n   // redis 配置  \n	RedisConfig struct {  \n	   Host     string `yaml:\"host\"`  \n	   Port     string `yaml:\"port\"`  \n	   Password string `yaml:\"password\"`  \n	   DB       int    `yaml:\"db\"`  \n	} `yaml:\"redis_config\"`\n}\n```\n## 4.5 创建数据库连接并自动生成数据库表\n在 `service` 目录下创建 `index.go`\n```go\npackage service  \n  \nimport (  \n   \"GinCoBlog/config\"  \n   \"GinCoBlog/entity\"   \"fmt\"   \"gorm.io/driver/mysql\"   \"gorm.io/gorm\")  \n  \n// Pool /** 创建数据库连接池  \nfunc Pool() *gorm.DB {  \n   // 获取数据库配置  \n   dbConfig := config.Default().DataBase  \n   fmt.Println(dbConfig.Host)  \n   // 创建数据库连接  \n   db, err := gorm.Open(mysql.Open(dbConfig.UserName+\":\"+dbConfig.Password+\"@tcp(\"+dbConfig.Host+\":\"+dbConfig.Port+\")/\"+dbConfig.Schema+\"?charset=utf8mb4&parseTime=True&loc=Local\"), &gorm.Config{})  \n   // 连接失败  \n   if err != nil {  \n      panic(\"连接数据库失败\")  \n   }  \n   // 抛出数据库连接池  \n   return db  \n}  \n  \n// VerDataBase /** 验证数据库/表是否已经创建  \nfunc VerDataBase() {  \n   // 获取数据库连接池  \n   pool := Pool()  \n   // 验证sys_user表是否存在  \n   err := pool.AutoMigrate(&entity.SysUser{})\n   err = pool.AutoMigrate(&entity.ArticleType{})  \n   err = pool.AutoMigrate(&entity.Article{})  \n   err = pool.AutoMigrate(&entity.ArticleComments{})  \n   err = pool.AutoMigrate(&entity.FeedBack{})  \n   // 表创建失败  \n   if err != nil {  \n      panic(err)  \n   }  \n}\n\n// RedisClient Redis 数据库连接  \nfunc RedisClient() *redis.Client {  \n   // 拿到 Redis 数据库配置  \n   redisConfig := config.Default().RedisConfig  \n   rdb := redis.NewClient(&redis.Options{  \n      Addr:     redisConfig.Host + \":\" + redisConfig.Port,  \n      Password: redisConfig.Password,  \n      DB:       redisConfig.DB,  \n   })  \n   ctx := context.Background()  \n   if _, err := rdb.Ping(ctx).Result(); err != nil {  \n      log.Fatalln(err.Error())  \n   }  \n   return rdb  \n}\n```\n\n在 `main.go` 下\n```go\n/**  \n * @projectName:    GinCoBlog \n * @package:        GinCoBlog \n * @className:      main \n * @author:     张杰  \n * @description:  TODO  \n * @date:    2023/10/4 9:23 \n * @version:    1.0 */\npackage main  \n  \n// 引入相关依赖  \nimport (  \n   \"GinCoBlog/config\"  \n   \"GinCoBlog/middleware\"   routes \"GinCoBlog/router\"  \n   \"GinCoBlog/service\"   \"fmt\"   \"github.com/gin-gonic/gin\"   \"net/http\")  \n  \n// 项目主方法  \nfunc main() {  \n   // 获取项目路由  \n   router := gin.Default()  \n   // 挂载中间件  \n   router.Use(gin.Logger(), gin.Recovery(), middleware.LoggerToFile())  \n   // 加载代理中间件  \n   err := router.SetTrustedProxies([]string{\"192.168.1.0/24\"})  \n   if err != nil {  \n      fmt.Println(\"代理失败！\")  \n      return  \n   }  \n   // 验证数据表是否存在  \n   service.VerDataBase()  \n   // 编写项目基础接口  \n   router.GET(\"/\", func(c *gin.Context) {  \n      c.JSON(http.StatusOK, \"HelloWorld!\")  \n   })  \n   // 调用项目主路由  \n   routes.SetupRouterGroup(router.Group(\"/api\"))  \n   // 开启端口监听  \n   err = router.Run(\":\" + config.Default().Port)  \n   // 开启监听失败  \n   if err != nil {  \n      // 写入日志  \n      panic(\"项目启动失败!\")  \n      return  \n   }  \n}\n```\n\n## 4.6 定义返回值类型\n在 `config/ConfigDefault.go`下加入\n```go\n// Response 返回值类型  \ntype Response struct {  \n   Code    int         `json:\"code\"` // 响应值  \n   Message string      `json:\"msg\"`  // 提示信息  \n   Data    interface{} `json:\"data\"` // 数据  \n}\n```\n\n在 `utils` 下创建 `index.go`\n```go\n// resultType 返回值方法  \nfunc resultType(code int, msg string, data interface{}) config.Response {  \n   return config.Response{  \n      Code:    code,  \n      Message: msg,  \n      Data:    data,  \n   }  \n}  \n  \n// SuccessResult 成功响应  \nfunc SuccessResult(c *gin.Context, msg string, data interface{}) {  \n   c.JSON(http.StatusOK, resultType(http.StatusOK, msg, data))  \n}  \n  \n// FailResult 错误响应  \nfunc FailResult(c *gin.Context, msg string) {  \n   c.JSON(http.StatusBadRequest, resultType(http.StatusBadRequest, msg, nil))  \n}  \n  \n// ServerErrorResult 服务器错误响应  \nfunc ServerErrorResult(c *gin.Context) {  \n   c.JSON(http.StatusInternalServerError, resultType(http.StatusInternalServerError, \"服务器错误！\", nil))  \n}  \n  \n// AuthorizationResult 权限错误响应  \nfunc AuthorizationResult(c *gin.Context, msg string) {  \n   c.JSON(http.StatusUnauthorized, resultType(http.StatusUnauthorized, msg, nil))  \n}\n```\n## 4.7 编写用户名查重接口\n> 接口地址：`/api/user/userNameOccupy`\n\n在 `service` 目录下创建 `UserService.go` \n```go\npackage service  \n  \nimport (  \n   \"GinCoBlog/entity\"  \n   \"GinCoBlog/utils\"   \"errors\")  \n  \n// 获取数据库连接池  \nvar pool = Pool()  \n  \n// UserNameOccupyService 用户名查重  \nfunc UserNameOccupyService(userName string) (error, bool) {  \n   // 创建数据库数组对象  \n   var user []entity.SysUser  \n   // 验证用户名参数  \n   // 验证是否为空  \n   if utils.StrIsEmpty(userName) {  \n      return errors.New(\"参数为空\"), false  \n   }  \n   // 判断长度是否超出  \n   if len(userName) > 15 {  \n      return errors.New(\"参数超出 15 个字符\"), false  \n   }  \n   // 判断用户名中是否含有非法字符串  \n   // 通过调用 gorm api 进行查找数据库  \n   pool.Where(\"user_name=?\", userName).Find(&user)  \n   // 判断查询的数组长度是否大于1  \n   if len(user) > 1 {  \n      return errors.New(\"数据库存储异常！\"), false  \n   }  \n   // 返回用户是否存在  \n   return nil, len(user) == 0  \n}\n```\n\n在 `requset/UserRequest.go` 下\n```go\npackage request  \n  \n// UserNameOccupyParams 用户名查重参数  \ntype UserNameOccupyParams struct {  \n   UserName string `json:\"user_name\" binding:\"required,min=3,max=15\"`  \n}\n```\n\n在 `controller/UserController.go`下添加\n```go\n// UserNameOccupy 用户名查重  \nfunc UserNameOccupy(c *gin.Context) {  \n    // 获取参数接口实例  \n	var param request.UserNameOccupyParams  \n	// 绑定参数  \n	err := c.ShouldBindJSON(&param)  \n	// 参数绑定失败  \n	if err != nil {  \n	   utils.FailResult(c, \"参数错误！\")  \n	   return  \n	}  \n	// 调用接口查找用户名是否已存在  \n	err, isUserName := service.UserNameOccupyService(param.UserName)  \n	// 如果发生错误  \n	if err != nil {  \n	   utils.FailResult(c, err.Error())  \n	   return  \n	}  \n	// 判断用户名是否存在  \n	if isUserName {  \n	   utils.FailResult(c, \"用户名已存在！\")  \n	   return  \n	}  \n	// 如果用户名不存在  \n	utils.SuccessResult(c, \"可以使用\", nil)\n}\n```\n\n在 `router/UserRouter.go`下添加\n```go\n// 用户名查重  \nrouter.GET(\"/userNameOccupy\", controller.UserNameOccupy)\n```\n\n运行\n```bash\ngo run main.go\n```\n测试\n> 打开 `postman/apiPost`进行测试\n![](http://137.175.84.209:88/article/26a1f9cb-8ec8-46ae-96bb-560def6fb95b.png)\n\n## 4.8 编写电话号码查重接口\n> 接口地址：`/api/user/phoneOccupy`\n\n在 `Application.yaml` 下添加：\n```yaml\n# 正则  \nregular:  \n  # 电话号码正则  \n  phone: \'^(13[0-9]|14[5-9]|15[0-35-9]|16[6]|17[0-8]|18[0-9]|19[0-9]|147|166|17[0-1]|162)\\d{8}$\'  \n```\n\n在 `config/ConfigDefault.go`\n```go\n// Config 配置 yaml 结构  \ntype Config struct {  \n   // 端口号  \n   Port string `yaml:\"port\"`  \n   // 数据库配置  \n   DataBase struct {  \n      Host     string `yaml:\"host\"`  \n      Port     string `yaml:\"port\"`  \n      UserName string `yaml:\"user_name\"`  \n      Password string `yaml:\"password\"`  \n      Schema   string `yaml:\"schema\"`  \n   } `yaml:\"data_base\"`  \n   // 日志配置  \n   LogConfig struct {  \n      Path string `yaml:\"path\"` // 日志存放路径  \n      Name string `yaml:\"name\"` // 日志名称  \n   } `yaml:\"log_config\"`  \n   // 正则配置  \n   Regular struct {  \n      Phone string `yaml:\"phone\"` // 电话号码正则\n   } `yaml:\"regular\"`  \n}\n// PhoneReg /** 定义电话号码正则  \nvar PhoneReg = Default().Regular.Phone  \n  \n// EmailReg /** 定义邮箱正则  \nvar EmailReg = Default().Regular.Email\n```\n\n在 `utils/index.go` 下\n```go\n// VerPhoneReg /** 验证电话号码格式  \nfunc VerPhoneReg(phone string) bool {  \n   phoneReg := regexp.MustCompile(config.PhoneReg)  \n   return !phoneReg.MatchString(phone)  \n}  \n```\n\n在 `service` 目录下创建 `UserService.go` \n```go\n// PhoneOccupyService 电话号码查重  \nfunc PhoneOccupyService(phone string) (error, bool) {  \n   // 创建数据库数组对象  \n   var user []entity.SysUser  \n   // 验证用户名参数  \n   // 验证是否为空  \n   if utils.StrIsEmpty(phone) {  \n      return errors.New(\"参数为空\"), false  \n   }  \n   // 判断长度是否超出  \n   if len(phone) != 11 {  \n      return errors.New(\"电话号码格式错误\"), false  \n   }  \n   // 判断用户名中是否含有非法字符串  \n   // 通过调用 gorm api 进行查找数据库  \n   pool.Where(\"phone=?\", phone).Find(&user)  \n   // 判断查询的数组长度是否大于 1   if len(user) > 1 {  \n      // 将错误写入日志  \n      logrus.Error(\"数据库内存有多个相同的电话号码\")  \n      // 将信息返回  \n      return errors.New(\"电话号码已存在\"), false  \n   }  \n   // 返回用户是否存在  \n   return nil, len(user) == 1  \n}\n```\n\n在 `requset/UserRequest.go` 下\n```go\n// PhoneOccupyParams 电话号码查重参数  \ntype PhoneOccupyParams struct {  \n   Phone string `json:\"phone\" binding:\"required,len=11\"`  \n}\n```\n\n在 `controller/UserController.go`下\n```go\n// PhoneOccupy 电话号码查重  \nfunc PhoneOccupy(c *gin.Context) {  \n   // 获取参数接口实例  \n   var param request.PhoneOccupyParams  \n   // 绑定参数  \n   err := c.ShouldBindJSON(&param)  \n   // 参数绑定失败  \n   if err != nil {  \n      utils.FailResult(c, \"参数错误！\")  \n      return  \n   }  \n   // 调用接口查找用户名是否已存在  \n   err, isUserName := service.PhoneOccupyService(param.Phone)  \n   // 如果发生错误  \n   if err != nil {  \n      utils.FailResult(c, err.Error())  \n      return  \n   }  \n   // 判断用户名是否存在  \n   if isUserName {  \n      utils.FailResult(c, \"电话号码已存在！\")  \n      return  \n   }  \n   // 如果用户名不存在  \n   utils.SuccessResult(c, \"可以使用\", nil)  \n}\n```\n\n在 `router/UserRouter.go`下\n```go\n// 电话号码查重  \nrouter.GET(\"/phoneOccupy\", controller.PhoneOccupy)\n```\n\n运行\n```bash\ngo run main.go\n```\n测试\n> 打开 `postman/apiPost`进行测试\n![](http://137.175.84.209:88/article/129f1b32-620f-46af-9248-78e2be15a27a.png)\n\n## 4.9 编写邮箱查重接口\n> 接口地址：`/api/user/emailOccupy`\n\n在 `Application.yaml` 下\n```yaml\n# 正则  \nregular:  \n  # 电话号码正则  \n  phone: \'^(13[0-9]|14[5-9]|15[0-35-9]|16[6]|17[0-8]|18[0-9]|19[0-9]|147|166|17[0-1]|162)\\d{8}$\'  \n  # 邮箱正则  \n  email: \'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$\'\n```\n\n在 `config/ConfigDefault.go` 下\n```go\n// Config 配置 yaml 结构  \ntype Config struct {  \n   // 端口号  \n   Port string `yaml:\"port\"`  \n   // 数据库配置  \n   DataBase struct {  \n      Host     string `yaml:\"host\"`  \n      Port     string `yaml:\"port\"`  \n      UserName string `yaml:\"user_name\"`  \n      Password string `yaml:\"password\"`  \n      Schema   string `yaml:\"schema\"`  \n   } `yaml:\"data_base\"`  \n   // 日志配置  \n   LogConfig struct {  \n      Path string `yaml:\"path\"` // 日志存放路径  \n      Name string `yaml:\"name\"` // 日志名称  \n   } `yaml:\"log_config\"`  \n   // 正则配置  \n   Regular struct {  \n      Phone string `yaml:\"phone\"` // 电话号码正则  \n      Email string `yaml:\"email\"` // 邮箱正则  \n   } `yaml:\"regular\"`  \n}\n// EmailReg /** 定义邮箱正则  \nvar EmailReg = Default().Regular.Email\n```\n\n在 `utils/index.go` 下\n```go\n// VerEmailReg /** 验证电话号码格式  \nfunc VerEmailReg(email string) bool {  \n   emailReg := regexp.MustCompile(config.EmailReg)  \n   return !emailReg.MatchString(email)  \n}\n```\n\n在 `service` 目录下创建 `UserService.go` \n```go\n// EmailOccupyService 邮箱查重  \nfunc EmailOccupyService(email string) (error, bool) {  \n   // 创建数据库数组对象  \n   var user []entity.SysUser  \n   // 验证用户名参数  \n   // 验证是否为空  \n   if utils.StrIsEmpty(email) {  \n      return errors.New(\"参数为空\"), false  \n   }  \n   // 判断邮箱格式是否正确  \n   if utils.VerEmailReg(email) {  \n      return errors.New(\"邮箱格式错误\"), false  \n   }  \n   // 判断用户名中是否含有非法字符串  \n   // 通过调用 gorm api 进行查找数据库  \n   pool.Where(\"email=?\", email).Find(&user)  \n   // 判断查询的数组长度是否大于 1   if len(user) > 1 {  \n      // 将错误写入日志  \n      logrus.Error(\"数据库内存有多个相同的邮箱\")  \n      // 将信息返回  \n      return errors.New(\"邮箱已存在\"), false  \n   }  \n   // 返回用户是否存在  \n   return nil, len(user) == 1  \n}\n```\n\n在 `requset/UserRequest.go` 下\n```go\n// EmailOccupyParams 邮箱查重参数  \ntype EmailOccupyParams struct {  \n   Email string `json:\"email\" binding:\"required\"`  \n}\n```\n\n在 `controller/UserController.go`下\n```go\n// EmailOccupy 邮箱查重  \nfunc EmailOccupy(c *gin.Context) {  \n   // 获取参数接口实例  \n   var param request.EmailOccupyParams  \n   // 绑定参数  \n   err := c.ShouldBindJSON(&param)  \n   // 参数绑定失败  \n   if err != nil {  \n      utils.FailResult(c, \"参数错误！\")  \n      return  \n   }  \n   // 调用接口查找用户名是否已存在  \n   err, isUserName := service.EmailOccupyService(param.Email)  \n   // 如果发生错误  \n   if err != nil {  \n      utils.FailResult(c, err.Error())  \n      return  \n   }  \n   // 判断用户名是否存在  \n   if isUserName {  \n      utils.FailResult(c, \"邮箱已存在！\")  \n      return  \n   }  \n   // 如果用户名不存在  \n   utils.SuccessResult(c, \"可以使用\", nil)  \n}\n```\n\n在 `router/UserRouter.go`下\n```go\n// 邮箱查重  \nrouter.GET(\"/emailOccupy\", controller.EmailOccupy)\n```\n\n运行\n```bash\ngo run main.go\n```\n测试\n> 打开 `postman/apiPost`进行测试\n![](http://137.175.84.209:88/article/f8a40d17-8c41-425b-8798-229361e809c5.png)\n\n## 4.10 编写邮箱验证码接口\n> 接口地址：`/api/user/sendEmailCode`\n\n在 `Application.yaml` 下添加：\n```yaml\n# 邮箱配置  \nemailConfig:  \n  emailAddress: \'co-blog@qq.com\'  \n  emailName: \'CoBlog站长\'  \n  password: \'qgiegwujfquqbjfd\'  \n  smtpServer: \'smtp.qq.com\'  \n  smtpPort: 587\n```\n\n在 `config/ConfigDefault.go`\n```go\n// Config 配置 yaml 结构  \ntype Config struct {  \n   // 端口号  \n   Port string `yaml:\"port\"`  \n   // 数据库配置  \n   DataBase struct {  \n      Host     string `yaml:\"host\"`  \n      Port     string `yaml:\"port\"`  \n      UserName string `yaml:\"user_name\"`  \n      Password string `yaml:\"password\"`  \n      Schema   string `yaml:\"schema\"`  \n   } `yaml:\"data_base\"`  \n   // 日志配置  \n   LogConfig struct {  \n      Path string `yaml:\"path\"`  \n      Name string `yaml:\"name\"`  \n   } `yaml:\"log_config\"`  \n   // 正则配置  \n   Regular struct {  \n      Phone string `yaml:\"phone\"`  \n      Email string `yaml:\"email\"`  \n   } `yaml:\"regular\"`  \n   // 邮箱配置  \n   EmailConfig struct {  \n      EmailAddress string `yaml:\"email_address\"`  \n      EmailName    string `yaml:\"email_name\"`  \n      Password     string `yaml:\"password\"`  \n      SmtpServer   string `yaml:\"smtp_server\"`  \n      SmtpPort     int    `yaml:\"smtp_port\"`  \n   } `yaml:\"email_config\"`  \n}\n// EmailConfig /** 邮箱发送配置  \nvar EmailConfig = Default().EmailConfig\n```\n\n在 `utils/index.go` 下\n```go\n// generateVerificationCode /** 生成验证码  \nfunc generateVerificationCode() string {  \n   source := rand.NewSource(time.Now().UnixNano())  \n   r := rand.New(source)  \n   code := \"\"  \n   for i := 0; i < 6; i++ {  \n      code += fmt.Sprintf(\"%d\", r.Intn(10))  \n   }  \n   return code  \n}  \n  \nfunc SendEmail(email string) string {  \n   // 生成验证码  \n   code := generateVerificationCode()  \n   // 创建消息  \n   m := gomail.NewMessage()  \n   // 设置发件地址和发件人  \n   m.SetAddressHeader(\"From\", config.EmailConfig.EmailAddress, config.EmailConfig.EmailName)  \n   // 发送地址  \n   m.SetHeader(\"To\", email)  \n   // 设置标题  \n   m.SetHeader(\"Subject\", \"验证码\")  \n   // 设置内容  \n   m.SetBody(\"text/html\", `  \n            <p>您好！</p>  \n            <p>您的验证码是：<strong style=\"color:orangered;\">`+code+`</strong></p>  \n         <p>此验证码在 5 分钟内有效</p>  \n            <p>如果不是您本人操作，请无视此邮件</p>  \n        `)  \n   // 使用 smtp发送邮件  \n   s := gomail.NewDialer(config.EmailConfig.SmtpServer, config.EmailConfig.SmtpPort, config.EmailConfig.EmailAddress, config.EmailConfig.Password)  \n  \n   if err := s.DialAndSend(m); err != nil {  \n      panic(\"发送失败！\")  \n   }  \n   return code  \n}\n```\n\n在 `service` 目录下创建 `UserService.go` \n```go\n// SendMsgCodeService 发送邮箱验证码  \nfunc SendMsgCodeService(email string) (error, bool) {  \n   // 验证用户名参数  \n   // 验证是否为空  \n   if utils.StrIsEmpty(email) {  \n      return errors.New(\"参数为空\"), false  \n   }  \n   // 判断邮箱格式是否正确  \n   if utils.VerEmailReg(email) {  \n      return errors.New(\"邮箱格式错误\"), false  \n   }  \n   // 判断用户名中是否含有非法字符串  \n   // 发送验证码  \n   code := utils.SendEmail(email)  \n   // 判断生成的验证码格式是否正确  \n   if len(code) != 6 {  \n      return errors.New(\"验证码发送失败\"), false  \n   }  \n   // 将 code 存入 redis 5 分钟有效期  \n   if _, err := RedisClient().Set(ctx, email, code, 5*time.Minute).Result(); err != nil {  \n      return errors.New(\"发送失败\"), false  \n   }  \n   // 返回  \n   return nil, true  \n}\n```\n\n在 `requset/UserRequest.go` 下\n```go\n// SendEmailParams 邮箱查重参数  \ntype SendEmailParams struct {  \n   Email string `json:\"email\" binding:\"required\"`  \n}\n```\n\n在 `controller/UserController.go`下\n```go\n// SendEmailCode 获取邮箱验证码  \nfunc SendEmailCode(c *gin.Context) {  \n   // 获取参数接口实例  \n   var param request.SendEmailParams  \n   // 绑定参数  \n   err := c.ShouldBindJSON(&param)  \n   // 参数绑定失败  \n   if err != nil {  \n      utils.FailResult(c, \"参数错误！\")  \n      return  \n   }  \n   // 调用接口发送验证码  \n   err, sendStatus := service.SendMsgCodeService(param.Email)  \n   // 如果发生错误  \n   if err != nil {  \n      utils.FailResult(c, err.Error())  \n      return  \n   }  \n   // 发送失败  \n   if !sendStatus {  \n      utils.FailResult(c, \"发送失败！\")  \n      return  \n   }  \n   // 发送成功  \n   utils.SuccessResult(c, \"发送成功！\", nil)  \n}\n```\n\n在 `router/UserRouter.go`下\n```go\n// 获取邮箱验证码  \nrouter.POST(\"/sendEmailCode\", controller.SendEmailCode)\n```\n\n运行\n```bash\ngo run main.go\n```\n测试\n> 打开 `postman/apiPost`进行测试\n![](http://137.175.84.209:88/article/e9a1e589-3416-4adb-9343-24ae6e303e93.png)\n\n> 邮箱截图\n![](http://137.175.84.209:88/article/01d40408-a67c-44cc-b89a-40d98d8ca202.jpg)\n\n## 4.11 编写注册接口\n> 接口地址：`/api/user/register`\n\n在 `Application.yaml` 下添加：\n```yaml\n# 加密  \nencryption:  \n  # 私钥  \n  private_key:  \n    password: \'自定义私钥\'  \n  # 盐值  \n  salt:  \n    password: 自定义盐值\n```\n\n在 `config/ConfigDefault.go`\n```go\n// Config 配置 yaml 结构  \ntype Config struct {  \n   // 端口号  \n   Port string `yaml:\"port\"`  \n   // 数据库配置  \n   DataBase struct {  \n      Host     string `yaml:\"host\"`  \n      Port     string `yaml:\"port\"`  \n      UserName string `yaml:\"user_name\"`  \n      Password string `yaml:\"password\"`  \n      Schema   string `yaml:\"schema\"`  \n   } `yaml:\"data_base\"`  \n   // 日志配置  \n   LogConfig struct {  \n      Path string `yaml:\"path\"`  \n      Name string `yaml:\"name\"`  \n   } `yaml:\"log_config\"`  \n   // 正则配置  \n   Regular struct {  \n      Phone string `yaml:\"phone\"`  \n      Email string `yaml:\"email\"`  \n   } `yaml:\"regular\"`  \n   // 邮箱配置  \n   EmailConfig struct {  \n      EmailAddress string `yaml:\"email_address\"`  \n      EmailName    string `yaml:\"email_name\"`  \n      Password     string `yaml:\"password\"`  \n      SmtpServer   string `yaml:\"smtp_server\"`  \n      SmtpPort     int    `yaml:\"smtp_port\"`  \n   } `yaml:\"email_config\"`  \n   // redis 配置  \n   RedisConfig struct {  \n      Host     string `yaml:\"host\"`  \n      Port     string `yaml:\"port\"`  \n      Password string `yaml:\"password\"`  \n      DB       int    `yaml:\"db\"`  \n   } `yaml:\"redis_config\"`  \n   // 加密配置  \n   Encryption struct {  \n      // 私钥  \n      PrivateKey struct {  \n         Password string `yaml:\"password\"`  \n      } `yaml:\"private_key\"`  \n      // 盐值  \n      Salt struct {  \n         Password int `yaml:\"password\"`  \n      } `yaml:\"salt\"`  \n   } `yaml:\"encryption\"`  \n}\n// Encryption 加密配置  \nvar Encryption = Default().Encryption\n```\n\n在 `utils/index.go` 下\n```go\n// CreateUUID 生成 uuid\nfunc CreateUUID() string {  \n   uCode := uuid.NewV4()  \n   return uCode.String()  \n}  \n  \n// EncryptionPassword 密码加密  \nfunc EncryptionPassword(pwd string) string {  \n   password, err := bcrypt.GenerateFromPassword([]byte(pwd+config.Encryption.PrivateKey.Password), config.Encryption.Salt.Password)  \n   if err != nil {  \n      return \"\"  \n   }  \n   return string(password)  \n}\n```\n\n在 `service` 目录下创建 `UserService.go` \n```go\n// RegisterService 注册  \nfunc RegisterService(param *request.RegisterParams) (error, bool) {  \n   // 判断数据是否为空  \n   if utils.StrIsEmpty(param.UserName) || utils.StrIsEmpty(param.Phone) || utils.StrIsEmpty(param.Email) || utils.StrIsEmpty(param.Password) {  \n      return errors.New(\"参数为空\"), false  \n   }  \n   // 验证电话号码格式  \n   if utils.VerPhoneReg(param.Phone) {  \n      return errors.New(\"电话号码格式错误\"), false  \n   }  \n   // 验证邮箱格式  \n   if utils.VerEmailReg(param.Email) {  \n      return errors.New(\"邮箱格式错误\"), false  \n   }  \n   // 验证电话号码是否已存在  \n   if err, _ := PhoneOccupyService(param.Phone); err != nil {  \n      return err, false  \n   }  \n   // 验证邮箱是否已存在  \n   if err, _ := EmailOccupyService(param.Email); err != nil {  \n      return err, false  \n   }  \n   // 判断密码格式  \n   if len(param.Password) != 32 || len(param.VerPassword) != 32 {  \n      return errors.New(\"密码为空\"), false  \n   }  \n   // 判断两次密码是否一致  \n   if param.Password != param.VerPassword {  \n      return errors.New(\"两次密码不一致\"), false  \n   }  \n   // 判断验证码是否正确  \n   result, err := RedisClient().Get(ctx, param.Email).Result()  \n   if err != nil {  \n      return errors.New(\"验证码失效\"), false  \n   }  \n   if result != param.EmailCode {  \n      return errors.New(\"验证码错误！\"), false  \n   }  \n   // 将密码进行二次加密  \n   encryptionPwd := utils.EncryptionPassword(param.Password)  \n   // 将用户数据存入数据库  \n   if err := pool.Create(&entity.SysUser{  \n      UserName: param.UserName,  \n      Phone:    param.Phone,  \n      Password: encryptionPwd,  \n      Email:    param.Email,  \n      UUID:     utils.CreateUUID(),  \n   }).Error; err != nil {  \n      return errors.New(\"注册失败！\"), false  \n   }  \n   // 判断  \n   return nil, true  \n}\n```\n\n在 `requset/UserRequest.go` 下\n```go\n// RegisterParams 注册参数  \ntype RegisterParams struct {  \n   UserName    string `json:\"user_name\" binding:\"required,min=3,max=15\"`  \n   Phone       string `json:\"phone\" binding:\"required,len=11\"`  \n   Email       string `json:\"email\" binding:\"required\"`  \n   EmailCode   string `json:\"email_code\" binding:\"required,len=6\"`  \n   Password    string `json:\"password\" binding:\"required,len=32\"`  \n   VerPassword string `json:\"ver_password\" binding:\"required,len=32\"`  \n}\n```\n\n在 `controller/UserController.go`下\n```go\n// Register 注册  \nfunc Register(c *gin.Context) {  \n   // 获取参数接口实例  \n   var param request.RegisterParams  \n   // 绑定参数  \n   err := c.ShouldBindJSON(&param)  \n   // 参数绑定失败  \n   if err != nil {  \n      utils.FailResult(c, \"参数错误！\")  \n      return  \n   }  \n   // 验证完成后  \n   err, status := service.RegisterService(&param)  \n   if err != nil {  \n      utils.FailResult(c, err.Error())  \n      return  \n   }  \n   // 注册失败  \n   if !status {  \n      utils.FailResult(c, \"注册失败\")  \n      return  \n   }  \n   // 注册成功  \n   utils.SuccessResult(c, \"注册成功！\", nil)  \n}\n```\n\n在 `router/UserRouter.go`下\n```go\n// 注册  \nrouter.POST(\"/register\", controller.Register)\n```\n\n运行\n```bash\ngo run main.go\n```\n测试\n> 打开 `postman/apiPost`进行测试\n> ![](http://137.175.84.209:88/article/a64385d1-59fd-4d46-b5d1-dce0adb158b4.png)\n\n\n## 4.12 编写电话号码登录接口\n> 接口地址：`/api/user/phoneLogin`\n\n在 `Application.yaml` 下添加：\n```yaml\n# token 配置  \ntoken:  \n  private_key: \'自定义私钥\'\n```\n\n在 `config/ConfigDefault.go`\n```go\n// Config 配置 yaml 结构  \ntype Config struct {  \n   // 端口号  \n   Port string `yaml:\"port\"`  \n   // 数据库配置  \n   DataBase struct {  \n      Host     string `yaml:\"host\"`  \n      Port     string `yaml:\"port\"`  \n      UserName string `yaml:\"user_name\"`  \n      Password string `yaml:\"password\"`  \n      Schema   string `yaml:\"schema\"`  \n   } `yaml:\"data_base\"`  \n   // 日志配置  \n   LogConfig struct {  \n      Path string `yaml:\"path\"`  \n      Name string `yaml:\"name\"`  \n   } `yaml:\"log_config\"`  \n   // 正则配置  \n   Regular struct {  \n      Phone string `yaml:\"phone\"`  \n      Email string `yaml:\"email\"`  \n   } `yaml:\"regular\"`  \n   // 邮箱配置  \n   EmailConfig struct {  \n      EmailAddress string `yaml:\"email_address\"`  \n      EmailName    string `yaml:\"email_name\"`  \n      Password     string `yaml:\"password\"`  \n      SmtpServer   string `yaml:\"smtp_server\"`  \n      SmtpPort     int    `yaml:\"smtp_port\"`  \n   } `yaml:\"email_config\"`  \n   // redis 配置  \n   RedisConfig struct {  \n      Host     string `yaml:\"host\"`  \n      Port     string `yaml:\"port\"`  \n      Password string `yaml:\"password\"`  \n      DB       int    `yaml:\"db\"`  \n   } `yaml:\"redis_config\"`  \n   // 加密配置  \n   Encryption struct {  \n      // 私钥  \n      PrivateKey struct {  \n         Password string `yaml:\"password\"`  \n      } `yaml:\"private_key\"`  \n      // 盐值  \n      Salt struct {  \n         Password int `yaml:\"password\"`  \n      } `yaml:\"salt\"`  \n   } `yaml:\"encryption\"`  \n   // token 配置  \n   Token struct {  \n      PrivateKey string `yaml:\"private_key\"`  \n   } `yaml:\"token\"`\n}\n\n// TokenPrivateKey Token 私钥配置  \nvar TokenPrivateKey = Default().Token.PrivateKey  \n  \n// TokenEffectAge Token 生命周期配置  \nconst TokenEffectAge = 7 * 24 * time.Hour\n```\n\n在 `utils/index.go` 下\n```go\n// ComparePassword 密码验证  \nfunc ComparePassword(hashPwd string, pwd string) bool {  \n   err := bcrypt.CompareHashAndPassword([]byte(hashPwd), []byte(pwd+config.Encryption.PrivateKey.Password))  \n   if err != nil {  \n      return false  \n   }  \n   return true  \n}  \n  \n// GenerateToken 生成 Token\nfunc GenerateToken(claims *request.TokenParams) string {  \n   //设置token有效期，也可不设置有效期，采用redis的方式  \n   //   1)将token存储在redis中，设置过期时间，token如没过期，则自动刷新redis过期时间，  \n   //   2)通过这种方式，可以很方便的为token续期，而且也可以实现长时间不登录的话，强制登录  \n   claims.ExpiresAt = time.Now().Add(config.TokenEffectAge).Unix()  \n   //生成token  \n   sign, err := jwt.NewWithClaims(jwt.SigningMethodHS256, claims).SignedString([]byte(config.TokenPrivateKey))  \n   if err != nil {  \n      //这里因为项目接入了统一异常处理，所以使用panic并不会使程序终止，如不接入，可使用原始方式处理错误  \n      log.Panicln(\"Token生成异常\")  \n      return \"\"  \n   }  \n   return sign  \n}\n```\n\n在 `service` 目录下创建 `UserService.go` \n```go\n// PhoneLoginService 电话号码登录  \nfunc PhoneLoginService(param *request.PhoneLoginParams) (error, bool, string) {  \n   // 创建数据库数组对象  \n   var user []entity.SysUser  \n   // 验证参数为空  \n   if utils.StrIsEmpty(param.Phone) || utils.StrIsEmpty(param.Password) {  \n      return errors.New(\"参数为空\"), false, \"\"  \n   }  \n   // 验证电话号码格式  \n   if utils.VerPhoneReg(param.Phone) {  \n      return errors.New(\"电话号码格式错误\"), false, \"\"  \n   }  \n   // 验证密码格式  \n   if len(param.Password) != 32 {  \n      return errors.New(\"密码格式错误\"), false, \"\"  \n   }  \n   // 判断此用户是否存在  \n   // 通过电话号码查询用户  \n   err := pool.Where(\"phone=?\", param.Phone).Find(&user).Error  \n   if err != nil {  \n      return errors.New(\"登录失败\"), false, \"\"  \n   }  \n   // 通过判断用户列表长度，判断是否有此用户  \n   if len(user) < 1 {  \n      return errors.New(\"此用户暂未注册！\"), false, \"\"  \n   }  \n   // 验证密码正确性  \n   if !utils.ComparePassword(user[0].Password, param.Password) {  \n      return errors.New(\"账号/密码错误！\"), false, \"\"  \n   }  \n   // 生成 Token   token := utils.GenerateToken(&request.TokenParams{  \n      UserInfo:       user[0],  \n      StandardClaims: jwt.StandardClaims{},  \n   })  \n   if utils.StrIsEmpty(token) {  \n      return errors.New(\"登录失败\"), false, \"\"  \n   }  \n   // 将 Token 存入 Redis   if _, err := RedisClient().Set(ctx, token, param.Phone, config.TokenEffectAge).Result(); err != nil {  \n      return errors.New(\"登录失败\"), false, \"\"  \n   }  \n  \n   return nil, true, token  \n}\n```\n\n在 `requset/UserRequest.go` 下\n```go\n// PhoneLoginParams 电话号码登录参数  \ntype PhoneLoginParams struct {  \n   Phone    string `json:\"phone\" binding:\"required,len=11\"`  \n   Password string `json:\"password\" binding:\"required,len=32\"`  \n}  \n  \n// TokenParams 定义 Token 类型  \ntype TokenParams struct {  \n   UserInfo           entity.SysUser // 用户信息  \n   jwt.StandardClaims                // token 配置  \n}\n```\n\n在 `controller/UserController.go`下\n```go\n// PhoneLogin 电话号码登录  \nfunc PhoneLogin(c *gin.Context) {  \n   // 拿到电话号码登录参数实体类  \n   var param request.PhoneLoginParams  \n   // 绑定参数  \n   err := c.ShouldBindJSON(&param)  \n   // 参数绑定失败  \n   if err != nil {  \n      utils.FailResult(c, \"参数错误！\")  \n      return  \n   }  \n   // 验证完成后  \n   err, status, token := service.PhoneLoginService(&param)  \n   if err != nil {  \n      utils.FailResult(c, err.Error())  \n      return  \n   }  \n   // 注册失败  \n   if !status {  \n      utils.FailResult(c, \"注册失败\")  \n      return  \n   }  \n   // 注册成功  \n   utils.SuccessResult(c, \"登录成功！\", map[string]interface{}{\"token\": token})  \n}\n```\n\n在 `router/UserRouter.go`下\n```go\n// 电话号码登录  \nrouter.POST(\"/phoneLogin\", controller.PhoneLogin)\n```\n\n运行\n```bash\ngo run main.go\n```\n测试\n> 打开 `postman/apiPost`进行测试\n> ![](http://137.175.84.209:88/article/6d305df3-3268-4e91-8175-483cc66094b1.png)\n\n\n## 4.13 编写邮箱登录接口\n> 接口地址：`/api/user/emailLogin`\n\n在 `Application.yaml` 下添加：\n```yaml\n\n```\n\n在 `config/ConfigDefault.go`\n```go\n\n```\n\n在 `utils/index.go` 下\n```go\n\n```\n\n在 `service` 目录下创建 `UserService.go` \n```go\n// EmailLoginService 邮箱登录  \nfunc EmailLoginService(param *request.EmailLoginParams) (error, bool, string) {  \n   // 创建数据库数组对象  \n   var user []entity.SysUser  \n   // 验证参数为空  \n   if utils.StrIsEmpty(param.Email) || utils.StrIsEmpty(param.Password) {  \n      return errors.New(\"参数为空\"), false, \"\"  \n   }  \n   // 验证电话号码格式  \n   if utils.VerEmailReg(param.Email) {  \n      return errors.New(\"电话号码格式错误\"), false, \"\"  \n   }  \n   // 验证密码格式  \n   if len(param.Password) != 32 {  \n      return errors.New(\"密码格式错误\"), false, \"\"  \n   }  \n   // 判断此用户是否存在  \n   // 通过电话号码查询用户  \n   err := pool.Where(\"email=?\", param.Email).Find(&user).Error  \n   if err != nil {  \n      return errors.New(\"登录失败\"), false, \"\"  \n   }  \n   // 通过判断用户列表长度，判断是否有此用户  \n   if len(user) < 1 {  \n      return errors.New(\"此用户暂未注册！\"), false, \"\"  \n   }  \n   // 验证密码正确性  \n   if !utils.ComparePassword(user[0].Password, param.Password) {  \n      return errors.New(\"账号/密码错误！\"), false, \"\"  \n   }  \n   // 生成 Token   token := utils.GenerateToken(&request.TokenParams{  \n      UserInfo:       user[0],  \n      StandardClaims: jwt.StandardClaims{},  \n   })  \n   if utils.StrIsEmpty(token) {  \n      return errors.New(\"登录失败\"), false, \"\"  \n   }  \n   // 将 Token 存入 Redis   if _, err := RedisClient().Set(ctx, token, param.Email, config.TokenEffectAge).Result(); err != nil {  \n      return errors.New(\"登录失败\"), false, \"\"  \n   }  \n  \n   return nil, true, token  \n}\n```\n\n在 `requset/UserRequest.go` 下\n```go\n// EmailLoginParams 邮箱登录参数  \ntype EmailLoginParams struct {  \n   Email    string `json:\"email\" binding:\"required\"`  \n   Password string `json:\"password\" binding:\"required,len=32\"`  \n}\n```\n\n在 `controller/UserController.go`下\n```go\n// EmailLogin 邮箱登录  \nfunc EmailLogin(c *gin.Context) {  \n   // 拿到电话号码登录参数实体类  \n   var param request.EmailLoginParams  \n   // 绑定参数  \n   err := c.ShouldBindJSON(&param)  \n   // 参数绑定失败  \n   if err != nil {  \n      utils.FailResult(c, \"参数错误！\")  \n      return  \n   }  \n   // 验证完成后  \n   err, status, token := service.EmailLoginService(&param)  \n   if err != nil {  \n      utils.FailResult(c, err.Error())  \n      return  \n   }  \n   // 注册失败  \n   if !status {  \n      utils.FailResult(c, \"注册失败\")  \n      return  \n   }  \n   // 注册成功  \n   utils.SuccessResult(c, \"登录成功！\", map[string]interface{}{\"token\": token})  \n}\n```\n\n在 `router/UserRouter.go`下\n```go\n// 邮箱登录  \nrouter.POST(\"/emailLogin\", controller.EmailLogin)\n```\n\n运行\n```bash\ngo run main.go\n```\n测试\n> 打开 `postman/apiPost`进行测试\n> ![](http://137.175.84.209:88/article/adf530ed-1109-4980-8276-b135e5d54f95.png)\n\n\n## 4.14 编写忘记密码接口\n> 接口地址：`/api/user/forgotPassword`\n\n在 `Application.yaml` 下添加：\n```yaml\n\n```\n\n在 `config/ConfigDefault.go`\n```go\n\n```\n\n在 `utils/index.go` 下\n```go\n\n```\n\n在 `service` 目录下创建 `UserService.go` \n```go\n// ForgotPassword 忘记密码  \nfunc ForgotPassword(param *request.ForgotPasswordParams) (error, bool) {  \n   // 创建数据库数组对象  \n   var user []entity.SysUser  \n   // 验证参数为空  \n   if utils.StrIsEmpty(param.Email) || utils.StrIsEmpty(param.EmailCode) || utils.StrIsEmpty(param.NewPassword) || utils.StrIsEmpty(param.VerPassword) {  \n      return errors.New(\"参数为空\"), false  \n   }  \n   // 验证邮箱格式  \n   if utils.VerEmailReg(param.Email) {  \n      return errors.New(\"邮箱格式错误\"), false  \n   }  \n   // 验证密码格式  \n   if len(param.NewPassword) != 32 || len(param.VerPassword) != 32 {  \n      return errors.New(\"密码格式错误\"), false  \n   }  \n   // 验证新密码和验证密码是否一致  \n   if param.NewPassword != param.VerPassword {  \n      return errors.New(\"两次密码不一致\"), false  \n   }  \n   // 验证验证码格式  \n   if len(param.EmailCode) != 6 {  \n      return errors.New(\"验证码格式错误\"), false  \n   }  \n   // 验证验证码是否正确  \n   if result, err := RedisClient().Get(ctx, param.Email).Result(); err != nil || result != param.EmailCode {  \n      return errors.New(\"验证码错误\"), false  \n   }  \n   // 删除 redis 中的验证码  \n   if _, err := RedisClient().Del(ctx, param.Email).Result(); err != nil {  \n      return errors.New(\"修改失败\"), false  \n   }  \n   // 判断此用户是否存在  \n   // 通过邮箱查询用户  \n   err := pool.Where(\"email=?\", param.Email).Find(&user).Error  \n   if err != nil {  \n      return errors.New(\"修改失败\"), false  \n   }  \n   // 通过判断用户列表长度，判断是否有此用户  \n   if len(user) < 1 {  \n      return errors.New(\"账号不存在\"), false  \n   }  \n   // 对密码进行加密  \n   encryptionPassword := utils.EncryptionPassword(param.NewPassword)  \n   // 修改密码 SQL   err = pool.Model(&entity.SysUser{}).Where(\"uid\", user[0].UID).Update(\"password\", encryptionPassword).Error  \n   if err != nil {  \n      return errors.New(\"修改失败\"), false  \n   }  \n   // 修改成功  \n   return nil, true  \n}\n```\n\n在 `requset/UserRequest.go` 下\n```go\n// ForgotPasswordParams 忘记密码参数  \ntype ForgotPasswordParams struct {  \n   Email       string `json:\"email\" binding:\"required\"`  \n   EmailCode   string `json:\"email_code\" binding:\"required,len=6\"`  \n   NewPassword string `json:\"new_password\" binding:\"required,len=32\"`  \n   VerPassword string `json:\"ver_password\" binding:\"required,len=32\"`  \n}\n```\n\n在 `controller/UserController.go`下\n```go\nfunc ForgotPassword(c *gin.Context) {  \n   // 获取参数接口实例  \n   var param request.ForgotPasswordParams  \n   // 绑定参数  \n   err := c.ShouldBindJSON(&param)  \n   // 参数绑定失败  \n   if err != nil {  \n      utils.FailResult(c, \"参数错误！\")  \n      return  \n   }  \n   // 验证完成后  \n   err, status := service.ForgotPassword(&param)  \n   if err != nil {  \n      utils.FailResult(c, err.Error())  \n      return  \n   }  \n   // 注册失败  \n   if !status {  \n      utils.FailResult(c, \"修改失败\")  \n      return  \n   }  \n   // 注册成功  \n   utils.SuccessResult(c, \"修改成功！\", nil)  \n}\n```\n\n在 `router/UserRouter.go`下\n```go\n// 忘记密码  \nrouter.POST(\"/forgotPassword\", controller.ForgotPassword)\n```\n\n运行\n```bash\ngo run main.go\n```\n测试\n> 打开 `postman/apiPost`进行测试\n> ![](http://137.175.84.209:88/article/bfafc410-c1f1-4faf-810f-0431a6e05e80.png)\n\n\n## 4.15 编写查询用户信息接口\n> 接口地址：`/api/user/userInfo`\n\n在 `Application.yaml` 下添加：\n```yaml\n\n```\n\n在 `config/ConfigDefault.go`\n```go\n\n```\n\n在 `utils/index.go` 下\n```go\n\n```\n\n在 `service` 目录下创建 `UserService.go` \n```go\n\n```\n\n在 `requset/UserRequest.go` 下\n```go\n\n```\n\n在 `controller/UserController.go`下\n```go\n// UserInfo 用户信息  \nfunc UserInfo(c *gin.Context) {  \n   // 获取用户信息  \n   user, _ := c.Get(\"user\")  \n   // 判断用户信息是否存在  \n   if user == nil {  \n      utils.FailResult(c, \"登陆失效，请重新登录！\")  \n      return  \n   }  \n   // 将user转化为 TokenParam类型  \n   tokenParam, ok := user.(*request.TokenParams)  \n   // 判断是否转化正确  \n   if !ok {  \n      utils.FailResult(c, \"登陆失效，请重新登录！\")  \n      return  \n   }  \n   // 返回用户信息  \n   utils.SuccessResult(c, \"获取成功！\", request.UserResponse{  \n      Name:          tokenParam.UserInfo.UserName,  \n      Phone:         tokenParam.UserInfo.Phone,  \n      HeadSculpture: tokenParam.UserInfo.HeadSculpture,  \n      Email:         tokenParam.UserInfo.Email,  \n      Limit:         tokenParam.UserInfo.Limit,  \n      Integral:      tokenParam.UserInfo.Integral,  \n      Member:        tokenParam.UserInfo.Member,  \n      CreateTime:    tokenParam.UserInfo.CreateTime.String(),  \n      UpdateTime:    tokenParam.UserInfo.UpdateTime.String(),  \n      UUID:          tokenParam.UserInfo.UUID,  \n   })  \n}\n```\n\n在 `router/UserRouter.go`下\n```go\n// 获取用户信息  \nrouter.GET(\"/userInfo\", controller.UserInfo)\n```\n\n运行\n```bash\ngo run main.go\n```\n测试\n> 打开 `postman/apiPost`进行测试\n> ![](http://137.175.84.209:88/article/fd3980c1-164a-46fd-a3b5-05cf4cd6cd74.png)\n\n\n## 4.16 编写修改用户信息接口\n> 接口地址：`/api/user/userNameOccupy`\n\n在 `Application.yaml` 下添加：\n```yaml\n\n```\n\n在 `config/ConfigDefault.go`\n```go\n\n```\n\n在 `utils/index.go` 下\n```go\n// GetCacheUser 获取缓存里的token信息  \nfunc GetCacheUser(c *gin.Context) (error, *request.TokenParams) {  \n   // 获取用户信息  \n   user, _ := c.Get(\"user\")  \n   // 判断用户信息是否存在  \n   if user == nil {  \n      return errors.New(\"登录状态错误，请重新登录\"), nil  \n   }  \n   // 将user转化为 TokenParam类型  \n   tokenParam, ok := user.(*request.TokenParams)  \n   // 判断是否转化正确  \n   if !ok {  \n      return errors.New(\"登录状态错误，请重新登录\"), nil  \n   }  \n   return nil, tokenParam  \n}\n```\n\n在 `service` 目录下创建 `UserService.go` \n```go\n// ModifyUserInfoService ModifyUserInfo 修改用户信息  \nfunc ModifyUserInfoService(param *request.ModifyUserInfoParams, userInfo *entity.SysUser) (error, bool) {  \n   // 判断参数是否为空  \n   if utils.StrIsEmpty(param.UserName) || utils.StrIsEmpty(param.Email) || utils.StrIsEmpty(param.Phone) || utils.StrIsEmpty(param.HeadSculpture) {  \n      return errors.New(\"参数为空\"), false  \n   }  \n   // 验证电话号码格式  \n   if utils.VerPhoneReg(param.Phone) {  \n      return errors.New(\"电话号码格式错误\"), false  \n   }  \n   // 验证验证码格式  \n   if len(param.EmailCode) != 6 {  \n      return errors.New(\"验证码格式错误\"), false  \n   }  \n   // 验证验证码是否正确  \n   if result, err := RedisClient().Get(ctx, userInfo.Email).Result(); err != nil || result != param.EmailCode {  \n      return errors.New(\"验证码错误\"), false  \n   }  \n   // 修改数据  \n   userInfo.UserName = param.UserName  \n   userInfo.Phone = param.Phone  \n   userInfo.Email = param.Email  \n   userInfo.HeadSculpture = param.HeadSculpture  \n   // 修改数据库  \n   err := pool.Model(&entity.SysUser{}).Where(\"uid\", userInfo.UID).Updates(userInfo).Error  \n   // 修改失败  \n   if err != nil {  \n      return errors.New(\"修改失败\"), false  \n   }  \n   // 修改成功  \n   return nil, true  \n}\n```\n\n在 `requset/UserRequest.go` 下\n```go\n// ModifyUserInfoParams 修改用户信息参数  \ntype ModifyUserInfoParams struct {  \n   UserName      string `json:\"user_name\" binding:\"required,min=3,max=15\"`  \n   Phone         string `json:\"phone\" binding:\"required,len=11\"`  \n   Email         string `json:\"email\" binding:\"required\"`  \n   HeadSculpture string `json:\"head_sculpture\" binding:\"required\"`  \n   EmailCode     string `json:\"email_code\" binding:\"required,len=6\"`  \n}\n```\n\n在 `controller/UserController.go`下\n```go\n// ModifyUserInfo 修改用户信息  \nfunc ModifyUserInfo(c *gin.Context) {  \n   var params request.ModifyUserInfoParams  \n   err := c.ShouldBindJSON(&params)  \n   if err != nil {  \n      utils.FailResult(c, \"参数错误\")  \n      return  \n   }  \n   err, tokenInfo := utils.GetCacheUser(c)  \n   if err != nil {  \n      utils.AuthorizationResult(c, err.Error())  \n      return  \n   }  \n   err, status := service.ModifyUserInfoService(&params, &tokenInfo.UserInfo)  \n   if err != nil {  \n      utils.FailResult(c, err.Error())  \n      return  \n   }  \n   if !status {  \n      utils.FailResult(c, \"修改失败\")  \n      return  \n   }  \n   utils.SuccessResult(c, \"修改成功\", nil)  \n}\n```\n\n在 `router/UserRouter.go`下\n```go\n// 修改用户信息  \nrouter.POST(\"/modifyUserInfo\", controller.ModifyUserInfo)\n```\n\n运行\n```bash\ngo run main.go\n```\n测试\n> 打开 `postman/apiPost`进行测试\n> ![](http://137.175.84.209:88/article/8c1fc809-558e-4d70-a441-933da3ce9edf.png)\n\n\n## 4.17 编写修改用户密码接口\n> 接口地址：`/api/user/userNameOccupy`\n\n在 `Application.yaml` 下添加：\n```yaml\n\n```\n\n在 `config/ConfigDefault.go`\n```go\n\n```\n\n在 `utils/index.go` 下\n```go\n\n```\n\n在 `service` 目录下创建 `UserService.go` \n```go\n// ModifyPasswordService 修改密码  \nfunc ModifyPasswordService(params *request.ModifyPasswordParams, userInfo *entity.SysUser) (error, bool) {  \n   // 判断参数为空  \n   if utils.StrIsEmpty(params.OldPassword) || utils.StrIsEmpty(params.NewPassword) {  \n      return errors.New(\"参数为空\"), false  \n   }  \n   // 判断新老密码是否一样  \n   if params.OldPassword == params.NewPassword {  \n      return errors.New(\"两次输入的密码一样\"), false  \n   }  \n   // 验证密码正确性  \n   if !utils.ComparePassword(userInfo.Password, params.OldPassword) {  \n      return errors.New(\"旧密码错误！\"), false  \n   }  \n   if params.NewPassword != params.VerifiedPassword {  \n      return errors.New(\"新密码与验证密码不一致！\"), false  \n   }  \n   // 将密码进行二次加密  \n   encryptionPwd := utils.EncryptionPassword(params.NewPassword)  \n   // 修改数据库  \n   err := pool.Model(&entity.SysUser{}).Where(\"uid\", userInfo.UID).Update(\"password\", encryptionPwd).Error  \n   if err != nil {  \n      return errors.New(\"修改失败\"), false  \n   }  \n   // 修改成功  \n   return nil, true  \n}\n```\n\n在 `requset/UserRequest.go` 下\n```go\n// ModifyPasswordParams 修改密码参数  \ntype ModifyPasswordParams struct {  \n   OldPassword      string `json:\"old_password\" binding:\"required,len=32\"`  \n   NewPassword      string `json:\"new_password\" binding:\"required,len=32\"`  \n   VerifiedPassword string `json:\"verified_password\" binding:\"required,len=32\"`  \n}\n```\n\n在 `controller/UserController.go`下\n```go\n// ModifyPassword 修改密码  \nfunc ModifyPassword(c *gin.Context) {  \n   // 获取参数类型对象  \n   var params request.ModifyPasswordParams  \n   // 绑定参数  \n   err := c.ShouldBindJSON(&params)  \n   // 绑定失败  \n   if err != nil {  \n      utils.FailResult(c, \"参数错误\")  \n      return  \n   }  \n   // 获取Token信息  \n   err, tokenInfo := utils.GetCacheUser(c)  \n   if err != nil {  \n      utils.AuthorizationResult(c, \"登录失效\")  \n      return  \n   }  \n   err, status := service.ModifyPasswordService(&params, &tokenInfo.UserInfo)  \n   if err != nil {  \n      utils.FailResult(c, err.Error())  \n      return  \n   }  \n   if !status {  \n      utils.FailResult(c, \"修改失败\")  \n      return  \n   }  \n   utils.SuccessResult(c, \"修改成功\", nil)  \n}\n```\n\n在 `router/UserRouter.go`下\n```go\n// 修改密码  \nrouter.POST(\"/modifyPassword\", controller.ModifyPassword)\n```\n\n运行\n```bash\ngo run main.go\n```\n测试\n> 打开 `postman/apiPost`进行测试\n> ![](http://137.175.84.209:88/article/281d38ec-f008-4732-9a22-3f8354648127.png)\n\n\n## 4.18 编写退出登录接口\n> 接口地址：`/api/user/logout`\n\n在 `Application.yaml` 下添加：\n```yaml\n\n```\n\n在 `config/ConfigDefault.go`\n```go\n\n```\n\n在 `utils/index.go` 下\n```go\n\n```\n\n在 `service` 目录下创建 `UserService.go` \n```go\n// LogoutService 退出登录  \nfunc LogoutService(param *request.TokenParams, token string) (error, bool) {  \n   // 判断参数是否为空  \n   if param == nil {  \n      return errors.New(\"退出失败\"), false  \n   }  \n   // 删除 Redis   \n   _, err := RedisClient().Del(ctx, token).Result()  \n   if err != nil {  \n      return err, false  \n   }  \n   return nil, true  \n}\n```\n\n在 `controller/UserController.go`下\n```go\n// Logout 退出登录  \nfunc Logout(c *gin.Context) {  \n   // 获取用户信息  \n   user, _ := c.Get(\"user\")  \n   // 获取Token  \n   header := c.GetHeader(\"Authorization\")  \n   // 判断用户信息是否存在  \n   if user == nil {  \n      utils.FailResult(c, \"登陆失效，请重新登录！\")  \n      return  \n   }  \n   // 将user转化为 TokenParam类型  \n   tokenParam, ok := user.(*request.TokenParams)  \n   // 判断是否转化正确  \n   if !ok {  \n      utils.FailResult(c, \"登陆失效，请重新登录！\")  \n      return  \n   }  \n   err, logout := service.LogoutService(tokenParam, header)  \n   if err != nil {  \n      utils.FailResult(c, \"退出失败\")  \n      return  \n   }  \n   if !logout {  \n      utils.FailResult(c, \"退出失败\")  \n      return  \n   }  \n   // 退出成功  \n   utils.SuccessResult(c, \"退出成功\", nil)  \n}\n```\n\n在 `router/UserRouter.go`下\n```go\n// 退出登录  \nrouter.POST(\"/logout\", controller.Logout)\n```\n\n运行\n```bash\ngo run main.go\n```\n测试\n> 打开 `postman/apiPost`进行测试\n> \n\n## 4.19 编写文件上传接口\n> 接口地址：`/api/upload/userAvatar`和 `/api/upload/articleIcon`\n\n在 `Application.yaml` 下添加：\n```yaml\n# 上传文件配置  \nupload:  \n  # 基础返回地址  \n  host: \'http://ip/image/\'  \n  # 存储位置  \n  img_load:  \n    user: \'uploads/\' # 用户头像存储目录  \n    article: \'uploads/article/\' # 文章图片存储目录  \n  # 文件大小  \n  max_size:  \n    # 图片  \n    img: 10  \n  # 可上传的类型  \n  img_type:  \n    - \'.jpg\'  \n    - \'.jpeg\'  \n    - \'.png\'  \n    - \'.bmp\'  \n    - \'.gif\'\n```\n\n在 `config/ConfigDefault.go`\n```go\n// Config 配置 yaml 结构  \ntype Config struct {  \n   // 端口号  \n   Port string `yaml:\"port\"`  \n   // 数据库配置  \n   DataBase struct {  \n      Host     string `yaml:\"host\"`  \n      Port     string `yaml:\"port\"`  \n      UserName string `yaml:\"user_name\"`  \n      Password string `yaml:\"password\"`  \n      Schema   string `yaml:\"schema\"`  \n   } `yaml:\"data_base\"`  \n   // 日志配置  \n   LogConfig struct {  \n      Path string `yaml:\"path\"`  \n      Name string `yaml:\"name\"`  \n   } `yaml:\"log_config\"`  \n   // 正则配置  \n   Regular struct {  \n      Phone string `yaml:\"phone\"`  \n      Email string `yaml:\"email\"`  \n   } `yaml:\"regular\"`  \n   // 邮箱配置  \n   EmailConfig struct {  \n      EmailAddress string `yaml:\"email_address\"`  \n      EmailName    string `yaml:\"email_name\"`  \n      Password     string `yaml:\"password\"`  \n      SmtpServer   string `yaml:\"smtp_server\"`  \n      SmtpPort     int    `yaml:\"smtp_port\"`  \n   } `yaml:\"email_config\"`  \n   // redis 配置  \n   RedisConfig struct {  \n      Host     string `yaml:\"host\"`  \n      Port     string `yaml:\"port\"`  \n      Password string `yaml:\"password\"`  \n      DB       int    `yaml:\"db\"`  \n   } `yaml:\"redis_config\"`  \n   // 加密配置  \n   Encryption struct {  \n      // 私钥  \n      PrivateKey struct {  \n         Password string `yaml:\"password\"`  \n      } `yaml:\"private_key\"`  \n      // 盐值  \n      Salt struct {  \n         Password int `yaml:\"password\"`  \n      } `yaml:\"salt\"`  \n   } `yaml:\"encryption\"`  \n   // token 配置  \n   Token struct {  \n      PrivateKey string `yaml:\"private_key\"`  \n   } `yaml:\"token\"`  \n   // 绕过中间件验证的地址  \n   NotVerifyUrl []string `yaml:\"not_verify_url\"`  \n   // 跨域中间件验证地址  \n   Cors struct {  \n      Ip      []string `yaml:\"ip\"`  \n      Methods []string `yaml:\"methods\"`  \n   } `yaml:\"cors\"`  \n   // 上传配置  \n   Upload struct {  \n      Host    string `yaml:\"host\"`  \n      ImgLoad struct {  \n         User    string `yaml:\"user\"`  \n         Article string `yaml:\"article\"`  \n      } `yaml:\"img_load\"`  \n      MaxSize struct {  \n         Img int64 `yaml:\"img\"`  \n      } `yaml:\"max_size\"`  \n      ImgType []string `yaml:\"img_type\"`  \n   } `yaml:\"upload\"`  \n}\n```\n\n在 `utils/index.go` 下\n```go\n// GenerateFileName 生成文件名  \nfunc GenerateFileName(originalName string) string {  \n   // 提取文件后缀  \n   extension := filepath.Ext(originalName)  \n   // 生成 UUID 字符串  \n   uuidFilename := uuid.NewV4().String()  \n   // 返回拼接字符串  \n   return uuidFilename + extension  \n}  \n  \n// IsAllowedImageType 定义允许上传的文件类型  \nfunc IsAllowedImageType(extension string) bool {  \n   // 获取允许的类型  \n   allowedImageTypes := config.Upload.ImgType  \n   // 判断是否符合该类型  \n   return contains(allowedImageTypes, extension)  \n}  \n  \n// 判断是否允许上传  \nfunc contains(slice []string, val string) bool {  \n   for _, item := range slice {  \n      if item == val {  \n         return true  \n      }  \n   }  \n   return false  \n}\n```\n\n在 `controller`下创建`UploadController.go`\n```go\npackage controller  \n  \nimport (  \n   \"GinCoBlog/config\"  \n   \"GinCoBlog/utils\"   \"fmt\"   \"github.com/gin-gonic/gin\"   \"path/filepath\")  \n  \nfunc UserAvatar(c *gin.Context) {  \n   file, err := c.FormFile(\"image\")  \n   if err != nil {  \n      utils.FailResult(c, err.Error())  \n      return  \n   }  \n  \n   // 生成 UUID 作为文件名的一部分  \n   newName := utils.GenerateFileName(file.Filename)  \n  \n   // 检查文件类型是否被允许上传  \n   ext := filepath.Ext(file.Filename)  \n   if !utils.IsAllowedImageType(ext) {  \n      utils.FailResult(c, \"只允许上传图片文件\")  \n      return  \n   }  \n  \n   // 检查文件大小  \n   if file.Size > (config.Upload.MaxSize.Img << 20) { // 限制文件大小为 5MB      utils.FailResult(c, \"文件大小超过限制\")  \n      return  \n   }  \n  \n   // 保存上传的文件到本地  \n   dst := fmt.Sprintf(config.Upload.ImgLoad.User+\"%s\", newName)  \n   if err := c.SaveUploadedFile(file, dst); err != nil {  \n      utils.FailResult(c, err.Error())  \n      return  \n   }  \n  \n   utils.SuccessResult(c, \"上传成功\", map[string]interface{}{\"fileName\": config.Upload.Host + newName})  \n}  \n  \nfunc ArticleIcon(c *gin.Context) {  \n   file, err := c.FormFile(\"image\")  \n   if err != nil {  \n      utils.FailResult(c, err.Error())  \n      return  \n   }  \n  \n   // 生成 UUID 作为文件名的一部分  \n   newName := utils.GenerateFileName(file.Filename)  \n  \n   // 检查文件类型是否被允许上传  \n   ext := filepath.Ext(file.Filename)  \n   if !utils.IsAllowedImageType(ext) {  \n      utils.FailResult(c, \"只允许上传图片文件\")  \n      return  \n   }  \n  \n   // 检查文件大小  \n   if file.Size > (config.Upload.MaxSize.Img << 20) { // 限制文件大小为 5MB      utils.FailResult(c, \"文件大小超过限制\")  \n      return  \n   }  \n  \n   // 保存上传的文件到本地  \n   dst := fmt.Sprintf(config.Upload.ImgLoad.Article+\"%s\", newName)  \n   if err := c.SaveUploadedFile(file, dst); err != nil {  \n      utils.FailResult(c, err.Error())  \n      return  \n   }  \n  \n   utils.SuccessResult(c, \"上传成功\", map[string]interface{}{\"fileName\": config.Upload.Host + newName})  \n}\n```\n\n在 `router`下创建 `UploadRouter.go`\n```go\npackage routes  \n  \nimport (  \n   \"GinCoBlog/controller\"  \n   \"github.com/gin-gonic/gin\")  \n  \nfunc UploadRouter(router *gin.RouterGroup) {  \n   // 用户头像  \n   router.PUT(\"/userAvatar\", controller.UserAvatar)  \n   // 文章图片  \n   router.PUT(\"/articleIcon\", controller.ArticleIcon)  \n}\n```\n\n在 `router/index.go`中添加\n```go\npackage routes  \n  \nimport \"github.com/gin-gonic/gin\"  \n  \n// SetupRouterGroup 项目主路由（一级）  \nfunc SetupRouterGroup(router *gin.RouterGroup) {  \n   // 调取用户路由  \n   UserRouter(router.Group(\"/user\"))  \n   // 调取上传路由  \n   UploadRouter(router.Group(\"/upload\"))  \n}\n```\n\n运行\n```bash\ngo run main.go\n```\n测试\n> 打开 `postman/apiPost`进行测试\n> ![](http://137.175.84.209:88/article/4c17da9b-d594-45b6-a957-0cf7f17d46b5.png)\n\n> ![](http://137.175.84.209:88/article/cc90d47b-b0e9-4bfc-aa86-5f1df7e41a21.png)\n\n\n## 4.20 编写获取文章类型接口\n> 接口地址：`/api/article/articleType`\n\n在 `Application.yaml` 下添加：\n```yaml\n# 不验证的接口地址  \nnot_verify_url:\n  - \'/api/article/articleType\'\n```\n\n在 `service` 目录下创建 `ArticleService.go` \n```go\n// ArticleTypeService 文章类型  \nfunc ArticleTypeService(list *[]entity.ArticleType) error {  \n   // 获取数据库内的文章类型数据  \n   if err := pool.Model(&entity.ArticleType{}).Where(\"type_visible\", 1).Find(&list).Error; err != nil {  \n      return errors.New(\"获取失败\")  \n   }  \n   return nil  \n}\n```\n\n在 `controller`下创建`ArticleController.go`\n```go\n// ArticleType 文章类型  \nfunc ArticleType(c *gin.Context) {  \n   // 定义类型  \n   var typeList []entity.ArticleType  \n   // 获取数据  \n   if err := service.ArticleTypeService(&typeList); err != nil {  \n      utils.FailResult(c, err.Error())  \n      return  \n   }  \n   utils.SuccessResult(c, \"获取成功\", map[string][]entity.ArticleType{\"articleType\": typeList})  \n}\n```\n\n在 `router`下创建`ArticleRouter.go`\n```go\npackage routes  \n  \nimport (  \n   \"GinCoBlog/controller\"  \n   \"github.com/gin-gonic/gin\")  \n  \n// ArticleRouter  定义文章路由（二级）  \nfunc ArticleRouter(router *gin.RouterGroup) {  \n   // 获取文章类型列表  \n   router.GET(\"/articleType\", controller.ArticleType)  \n}\n```\n\n运行\n```bash\ngo run main.go\n```\n测试\n> 打开 `postman/apiPost`进行测试\n> ![](http://137.175.84.209:88/article/306ece5f-5ae6-4caa-ade5-cd8c843848ef.png)\n\n\n## 4.21 编写获取文章列表接口\n> 接口地址：`/api/article/articleList`\n\n在 `Application.yaml` 下添加：\n```yaml\n# 不验证的接口地址  \nnot_verify_url:  \n  - \'/api/user/phoneOccupy\'  \n  - \'/api/user/emailOccupy\'  \n  - \'/api/user/register\'  \n  - \'/api/user/phoneLogin\'  \n  - \'/api/user/emailLogin\'  \n  - \'/api/user/sendEmailCode\'  \n  - \'/api/user/forgotPassword\'  \n  - \'/api/article/articleType\'  \n  - \'/api/article/articleList\'\n```\n\n在 `service/ArticleService.go`  \n```go\n// ArticleListByTypeId 根据文章类型查询文章列表  \nfunc ArticleListByTypeId(list *[]entity.Article, typeId int32) error {  \n   // 判断参数格式  \n   if typeId == 0 {  \n      return errors.New(\"参数为空\")  \n   }  \n   // 获取数据库内的文章类型数据  \n   if err := pool.Model(&entity.Article{}).Where(\"type_id\", typeId).Find(&list).Error; err != nil {  \n      return errors.New(\"获取失败\")  \n   }  \n   return nil  \n}\n```\n\n在 `requset/ArticleRequest.go` 下\n```go\n// ArticleListByTypeParam 根据类型 ID 查询的参数  \ntype ArticleListByTypeParam struct {  \n   TypeId int32 `form:\"type_id\" binding:\"required\"`  \n}\n```\n\n在 `controller/ArticleController.go`下\n```go\n// ArticleListByType 文章列表  \nfunc ArticleListByType(c *gin.Context) {  \n   var params request.ArticleListByTypeParam  \n   var articleList []entity.Article  \n   // 绑定参数  \n   err := c.ShouldBindQuery(&params)  \n   if err != nil {  \n      utils.FailResult(c, \"参数错误\")  \n      return  \n   }  \n   // 查询数据库  \n   if err := service.ArticleListByTypeId(&articleList, params.TypeId); err != nil {  \n      utils.FailResult(c, \"获取失败\")  \n      return  \n   }  \n   utils.SuccessResult(c, \"获取成功\", map[string][]entity.Article{\"rows\": articleList})  \n}\n```\n\n在 `router/ArticleRouter.go`下\n```go\n// 通过类型 ID 获取文章列表  \nrouter.GET(\"/articleList\", controller.ArticleListByType)\n```\n\n运行\n```bash\ngo run main.go\n```\n测试\n> 打开 `postman/apiPost`进行测试\n> ![](http://137.175.84.209:88/article/1552bc79-2570-49f1-ba52-9e36ef3e5c6e.png)\n\n\n## 4.22 编写获取文章详情接口\n> 接口地址：`/api/article/articleInfo`\n\n在 `Application.yaml` 下添加：\n```yaml\n# 不验证的接口地址  \nnot_verify_url:  \n  - \'/api/user/phoneOccupy\'  \n  - \'/api/user/emailOccupy\'  \n  - \'/api/user/register\'  \n  - \'/api/user/phoneLogin\'  \n  - \'/api/user/emailLogin\'  \n  - \'/api/user/sendEmailCode\'  \n  - \'/api/user/forgotPassword\'  \n  - \'/api/article/articleType\'  \n  - \'/api/article/articleList\'  \n  - \'/api/article/articleInfo\'\n```\n\n在 `service/ArticleService.go` \n```go\n// ArticleInfoByIdService 根据 ID 获取文章详情  \nfunc ArticleInfoByIdService(info *entity.Article, articleId int32) error {  \n   if articleId == 0 {  \n      return errors.New(\"参数为空\")  \n   }  \n   // 获取数据库信息  \n   if err := pool.Model(&entity.Article{}).Where(\"id=? AND article_visible=?\", articleId, 1).First(&info).Error; err != nil {  \n      return errors.New(\"获取失败\")  \n   }  \n   return nil  \n}\n```\n\n在 `requset/ArticleRequest.go` 下\n```go\n// ArticleInfoByIdParam 根据 ID 获取文章详情  \ntype ArticleInfoByIdParam struct {  \n   ArticleId int32 `form:\"article_id\" binding:\"required\"`  \n}\n```\n\n在 `controller/ArticleController.go`下\n```go\n// ArticleInfoById 文章详情  \nfunc ArticleInfoById(c *gin.Context) {  \n   var params request.ArticleInfoByIdParam  \n   var info entity.Article  \n   // 绑定参数  \n   err := c.ShouldBindQuery(&params)  \n   if err != nil {  \n      utils.FailResult(c, \"参数错误\")  \n      return  \n   }  \n   // 查询数据库  \n   if err := service.ArticleInfoByIdService(&info, params.ArticleId); err != nil {  \n      utils.FailResult(c, \"获取失败\")  \n      return  \n   }  \n   utils.SuccessResult(c, \"获取成功\", map[string]entity.Article{\"data\": info})  \n}\n```\n\n在 `router/ArticleRouter.go`下\n```go\n// 通过 ID 获取文章详情  \nrouter.GET(\"/articleInfo\", controller.ArticleInfoById)\n```\n\n运行\n```bash\ngo run main.go\n```\n测试\n> 打开 `postman/apiPost`进行测试\n> ![](http://137.175.84.209:88/article/e95be7d8-01db-4fa5-bdb8-5b2cd51c10e4.png)\n\n\n## 4.23 编写添加文章接口\n> 接口地址：`/api/article/addArticle`\n\n在 `service/ArticleService.go`\n```go\n// AddArticleService 添加文章  \nfunc AddArticleService(param *request.AddArticleParam, userInfo entity.SysUser) (error, bool) {  \n   // 判断参数是否为空  \n   if param.TypeId == 0 || utils.StrIsEmpty(param.Title) || utils.StrIsEmpty(param.Context) || utils.StrIsEmpty(param.Icon) {  \n      return errors.New(\"参数为空\"), false  \n   }  \n   // 判断参数是否合法  \n   // 将数据存入数据库  \n   err := pool.Model(&entity.Article{}).Create(&entity.Article{  \n      TypeId:  param.TypeId,  \n      UserId:  userInfo.UID,  \n      Title:   param.Title,  \n      Context: param.Context,  \n      Icon:    param.Icon,  \n   }).Error  \n   if err != nil {  \n      return errors.New(\"添加失败\"), false  \n   }  \n   return nil, true  \n}\n```\n\n在 `requset/ArticleRequest.go` 下\n```go\n// AddArticleParam 添加文章参数  \ntype AddArticleParam struct {  \n   TypeId  uint32 `json:\"typeId\" binding:\"required\"`  \n   Title   string `json:\"title\" binding:\"required\"`  \n   Context string `json:\"context\" binding:\"required\"`  \n   Icon    string `json:\"icon\" binding:\"required\"`  \n}\n```\n\n在 `controller/ArticleController.go`下\n```go\n// AddArticle 添加文章  \nfunc AddArticle(c *gin.Context) {  \n   // 获取参数实例  \n   var params request.AddArticleParam  \n   // 绑定参数  \n   err := c.ShouldBindJSON(&params)  \n   if err != nil {  \n      utils.FailResult(c, \"参数错误\")  \n      return  \n   }  \n   err, tokenInfo := utils.GetCacheUser(c)  \n   if err != nil {  \n      utils.AuthorizationResult(c, \"登录状态失效\")  \n      return  \n   }  \n   // 将数据添加到数据库  \n   err, status := service.AddArticleService(&params, tokenInfo.UserInfo)  \n   if err != nil {  \n      utils.FailResult(c, err.Error())  \n      return  \n   }  \n   if !status {  \n      utils.FailResult(c, \"添加失败\")  \n   }  \n   utils.SuccessResult(c, \"添加成功\", nil)  \n}\n```\n\n在 `router/ArticleRouter.go`下\n```go\n// 添加文章  \nrouter.POST(\"/addArticle\", controller.AddArticle)\n```\n\n运行\n```bash\ngo run main.go\n```\n测试\n> 打开 `postman/apiPost`进行测试\n> \n\n\n## 4.24 编写更新阅读量接口\n> 接口地址：`/api/article/updateRead`\n\n在 `Application.yaml` 下添加：\n```yaml\nnot_verify_url:  \n  - \'/api/user/phoneOccupy\'  \n  - \'/api/user/emailOccupy\'  \n  - \'/api/user/register\'  \n  - \'/api/user/phoneLogin\'  \n  - \'/api/user/emailLogin\'  \n  - \'/api/user/sendEmailCode\'  \n  - \'/api/user/forgotPassword\'  \n  - \'/api/article/articleType\'  \n  - \'/api/article/articleList\'  \n  - \'/api/article/articleInfo\'  \n  - \'/api/article/updateRead\'\n```\n\n在 `config/ConfigDefault.go`\n```go\n\n```\n\n在 `utils/index.go` 下\n```go\n\n```\n\n在 `service/ArticleService.go` 下\n```go\n// UpdateReadService 更新阅读量  \nfunc UpdateReadService(param *request.UpdateReadParam) (error, bool) {  \n   // 判断参数为空  \n   if param.ArticleId == 0 {  \n      return errors.New(\"参数为空\"), false  \n   }  \n   // 修改数据库  \n   if err := pool.Model(&entity.Article{}).Where(\"id\", param.ArticleId).UpdateColumn(\"read\", gorm.Expr(\"`read` + ?\", 1)).Error; err != nil {  \n      return errors.New(\"修改失败\"), false  \n   }  \n   // 修改成功  \n   return nil, true  \n}\n```\n\n在 `requset/ArticleRequest.go` 下\n```go\n// UpdateReadParam 更新阅读量  \ntype UpdateReadParam struct {  \n   ArticleId int32 `json:\"article_id\" binding:\"required\"`  \n}\n```\n\n在 `controller/ArticleController.go`下\n```go\n// UpdateRead 更新阅读量  \nfunc UpdateRead(c *gin.Context) {  \n   var params request.UpdateReadParam  \n   // 绑定参数  \n   err := c.ShouldBindJSON(&params)  \n   if err != nil {  \n      utils.FailResult(c, \"参数错误\")  \n      return  \n   }  \n   // 修改数据库  \n   err, status := service.UpdateReadService(&params)  \n   if err != nil {  \n      utils.FailResult(c, err.Error())  \n      return  \n   }  \n   // 判断状态  \n   if !status {  \n      utils.FailResult(c, \"设置失败\")  \n      return  \n   }  \n   // 设置成功  \n   utils.SuccessResult(c, \"更新成功\", nil)  \n}\n```\n\n在 `router/ArticleRouter.go`下\n```go\n// 更新阅读量  \nrouter.POST(\"/updateRead\", controller.UpdateRead)\n```\n\n运行\n```bash\ngo run main.go\n```\n测试\n> 打开 `postman/apiPost`进行测试\n\n## 4.25 编写查询评论列表接口\n> 接口地址：`/api/article/articleComment`\n\n在 `Application.yaml` 下添加：\n```yaml\nnot_verify_url:  \n  - \'/api/user/phoneOccupy\'  \n  - \'/api/user/emailOccupy\'  \n  - \'/api/user/register\'  \n  - \'/api/user/phoneLogin\'  \n  - \'/api/user/emailLogin\'  \n  - \'/api/user/sendEmailCode\'  \n  - \'/api/user/forgotPassword\'  \n  - \'/api/article/articleType\'  \n  - \'/api/article/articleList\'  \n  - \'/api/article/articleInfo\'  \n  - \'/api/article/updateRead\'  \n  - \'/api/article/articleComment\'\n```\n\n在 `config/ConfigDefault.go`\n```go\n\n```\n\n在 `utils/index.go` 下\n```go\n\n```\n\n在 `service/ArticleService.go`\n```go\n// ArticleCommentService 获取文章评论  \nfunc ArticleCommentService(param *request.ArticleCommentParam, comments *[]entity.ArticleComments) error {  \n   if param.ArticleId == 0 {  \n      return errors.New(\"参数为空\")  \n   }  \n   // 获取数据库信息  \nif err := pool.Table(\"article_comments\").  \n   Where(\"article_id\", param.ArticleId).  \n   Joins(\"INNER JOIN sys_user ON article_comments.user_id = sys_user.uid\").  \n   Select(\"article_comments.id, article_comments.article_id, article_comments.context, sys_user.user_name, sys_user.head_sculpture, sys_user.integral, sys_user.member\").  \n   Find(&comments).Error; err != nil {  \n   return errors.New(\"获取失败\")  \n}\n   // 获取成功  \n   return nil  \n}\n```\n在 `requset`下创建 `ArticleResponse.go`\n```go\n// ArticleCommentResponse 文章评论返回参数  \ntype ArticleCommentResponse struct {  \n   ID            uint32 `json:\"id\"`             // 评论ID  \n   ArticleID     uint32 `json:\"article_id\"`     // 文章ID  \n   Context       string `json:\"context\"`        // 评论内容  \n   UserName      string `json:\"user_name\"`      // 用户名  \n   HeadSculpture string `json:\"head_sculpture\"` // 头像 默认值  \n   Integral      uint32 `json:\"integral\"`       // 积分  \n   Member        uint8  `json:\"member\"`         // 会员  \n}\n```\n在 `requset/ArticleRequest.go` 下\n```go\n// ArticleCommentParam 文章评论参数  \ntype ArticleCommentParam struct {  \n   ArticleId int32 `form:\"article_id\" binding:\"required\"`  \n}\n```\n\n在 `controller/ArticleController.go`下\n```go\n// ArticleComment 获取文章评论  \nfunc ArticleComment(c *gin.Context) {  \n   var params request.ArticleCommentParam  \n   var commentList []entity.ArticleComments  \n  \n   // 绑定参数  \n   err := c.ShouldBindQuery(&params)  \n   if err != nil {  \n      utils.FailResult(c, \"参数错误\")  \n      return  \n   }  \n   // 查询数据库  \n   if err := service.ArticleCommentService(&params, &commentList); err != nil {  \n      utils.FailResult(c, err.Error())  \n      return  \n   }  \n   // 获取成功  \n   utils.SuccessResult(c, \"获取成功\", map[string][]entity.ArticleComments{\"rows\": commentList})  \n}\n```\n\n在 `router/ArticleRouter.go`下\n```go\n// 获取文章评论  \nrouter.GET(\"/articleComment\", controller.ArticleComment)\n```\n\n运行\n```bash\ngo run main.go\n```\n测试\n> 打开 `postman/apiPost`进行测试\n> ![](http://137.175.84.209:88/article/aeaf5752-5733-4e01-9eb5-6d78568922cc.png)\n\n\n## 4.26 编写上传评论接口\n> 接口地址：`/api/article/addComment`\n\n在 `service/ArticleService.go`\n```go\n// AddArticleCommentService 添加文章评论  \nfunc AddArticleCommentService(param *request.AddArticleCommentParam, userInfo entity.SysUser) (error, bool) {  \n   // 判断参数是否为空  \n   if param.ArticleId == 0 || utils.StrIsEmpty(param.Context) {  \n      return errors.New(\"参数为空\"), false  \n   }  \n   // 判断参数格式  \n   // 将数据存入数据库  \n   if err := pool.Model(&entity.ArticleComments{}).Create(&entity.ArticleComments{  \n      ArticleID: param.ArticleId,  \n      UserID:    userInfo.UID,  \n      Context:   param.Context,  \n   }).Error; err != nil {  \n      return errors.New(\"上传失败\"), false  \n   }  \n   // 添加成功  \n   return nil, true  \n}\n```\n\n在 `requset/ArticleRequest.go` 下\n```go\n// AddArticleCommentParam 添加文章评论  \ntype AddArticleCommentParam struct {  \n   ArticleId uint32 `json:\"article_id\" binding:\"required\"`  \n   Context   string `json:\"context\" binding:\"required\"`  \n}\n```\n\n在 `controller/ArticleController.go`下\n```go\n// AddArticleComment 添加文章评论  \nfunc AddArticleComment(c *gin.Context) {  \n   // 获取参数类型  \n   var param request.AddArticleCommentParam  \n   // 绑定参数  \n   err := c.ShouldBindJSON(&param)  \n   if err != nil {  \n      utils.FailResult(c, \"参数错误\")  \n      return  \n   }  \n   err, tokenInfo := utils.GetCacheUser(c)  \n   if err != nil {  \n      utils.AuthorizationResult(c, \"登录状态失效\")  \n      return  \n   }  \n   // 将数据添加到数据库  \n   err, status := service.AddArticleCommentService(&param, tokenInfo.UserInfo)  \n   if err != nil {  \n      utils.FailResult(c, err.Error())  \n      return  \n   }  \n   // 判断是否添加成功  \n   if !status {  \n      utils.FailResult(c, \"上传失败\")  \n      return  \n   }  \n   utils.SuccessResult(c, \"上传成功\", nil)  \n}\n```\n\n在 `router/ArticleRouter.go`下\n```go\n// 添加文章评论  \nrouter.POST(\"/addComment\", controller.AddArticleComment)\n```\n\n运行\n```bash\ngo run main.go\n```\n测试\n> 打开 `postman/apiPost`进行测试\n> ![](http://137.175.84.209:88/article/d7895cd8-f623-4a2f-8c7f-c296e38329da.png)\n\n\n## 4.27 编写用户反馈接口\n> 接口地址：`/api/user/userNameOccupy`\n\n在 `service` 目录下创建 `FeedBackService.go` \n```go\n// AddFeedBackService 添加用户反馈  \nfunc AddFeedBackService(param request.AddFeedBackParam, userInfo entity.SysUser) (error, bool) {  \n   // 验证数据  \n   if utils.StrIsEmpty(param.Context) {  \n      return errors.New(\"参数为空\"), false  \n   }  \n   // 验证数据  \n   // 向数据库内添加数据  \n   if err := pool.Model(&entity.FeedBack{}).Create(&entity.FeedBack{  \n      UserID:  userInfo.UID,  \n      Context: param.Context,  \n   }).Error; err != nil {  \n      return errors.New(\"上传失败\"), false  \n   }  \n   return nil, true  \n}\n```\n\n在 `requset` 下创建`FeedBackRequest.go`\n```go\n// AddFeedBackParam 添加反馈信息参数  \ntype AddFeedBackParam struct {  \n   Context string `json:\"context\" binding:\"required\"`  \n}\n```\n\n在 `controller`下创建`FeedBackController.go`\n```go\n// AddFeedBack 添加用户反馈  \nfunc AddFeedBack(c *gin.Context) {  \n   var param request.AddFeedBackParam  \n   // 绑定数据  \n   err := c.ShouldBindJSON(&param)  \n   if err != nil {  \n      utils.FailResult(c, \"参数错误\")  \n      return  \n   }  \n   err, tokenInfo := utils.GetCacheUser(c)  \n   if err != nil {  \n      utils.AuthorizationResult(c, \"登录状态失效\")  \n      return  \n   }  \n   // 向数据库内添加  \n   err, status := service.AddFeedBackService(param, tokenInfo.UserInfo)  \n   if err != nil {  \n      utils.FailResult(c, err.Error())  \n      return  \n   }  \n   // 判断是否成功  \n   if !status {  \n      utils.FailResult(c, \"反馈失败\")  \n      return  \n   }  \n   // 反馈成功  \n   utils.SuccessResult(c, \"反馈成功\", nil)  \n}\n```\n\n在 `router`下创建`FeedBackRouter.go`\n```go\n// FeedBackRouter 定义反馈路由（二级）  \nfunc FeedBackRouter(router *gin.RouterGroup) {  \n   // 添加反馈  \n   router.POST(\"/addFeedback\", controller.AddFeedBack)  \n}\n```\n\n在 `router/index.go`下\n```go\n// SetupRouterGroup 项目主路由（一级）  \nfunc SetupRouterGroup(router *gin.RouterGroup) {  \n   // 调取用户路由  \n   UserRouter(router.Group(\"/user\"))  \n   // 调取上传路由  \n   UploadRouter(router.Group(\"/upload\"))  \n   // 调取文章路由  \n   ArticleRouter(router.Group(\"/article\"))  \n   // 调取反馈路由  \n   FeedBackRouter(router.Group(\"/feedback\"))  \n}\n```\n\n运行\n```bash\ngo run main.go\n```\n测试\n> 打开 `postman/apiPost`进行测试\n> ![](http://137.175.84.209:88/article/2b5f6ed8-36a1-4eef-b7b6-63bb298e6fbe.png)\n\n\n## 4.28 编写查询VIP列表接口\n> 接口地址：`/api/user/userNameOccupy`\n\n在 `Application.yaml` 下添加：\n```yaml\n\n```\n\n在 `config/ConfigDefault.go`\n```go\n\n```\n\n在 `utils/index.go` 下\n```go\n\n```\n\n在 `service` 目录下创建 `UserService.go` \n```go\n\n```\n\n在 `requset/UserRequest.go` 下\n```go\n\n```\n\n在 `controller/UserController.go`下\n```go\n\n```\n\n在 `router/UserRouter.go`下\n```go\n\n```\n\n运行\n```bash\ngo run main.go\n```\n测试\n> 打开 `postman/apiPost`进行测试\n\n## 4.29 编写升级VIP接口\n> 接口地址：`/api/user/userNameOccupy`\n\n在 `Application.yaml` 下添加：\n```yaml\n\n```\n\n在 `config/ConfigDefault.go`\n```go\n\n```\n\n在 `utils/index.go` 下\n```go\n\n```\n\n在 `service` 目录下创建 `UserService.go` \n```go\n\n```\n\n在 `requset/UserRequest.go` 下\n```go\n\n```\n\n在 `controller/UserController.go`下\n```go\n\n```\n\n在 `router/UserRouter.go`下\n```go\n\n```\n\n运行\n```bash\ngo run main.go\n```\n测试\n> 打开 `postman/apiPost`进行测试\n\n\n# 5 打包\n## 5.1 生成接口文档\n在 apifox 上点击项目三个点->导出\n![[gin_co_blog_assets/Pasted image 20231018155343.png]]\n选择导出 MarkDown 导出就行\n\n## 5.2 exe 程序\n将项目右键，找到 Open In  --> Terminal\n![[gin_co_blog_assets/Pasted image 20231018160106.png]]\n\n```bash\n## 生成与项目同名的 exe 程序\ngo build .\n```\n## 5.3 linux 执行程序\n\n也是打开 Terminal\n\n输入以下命令:\n\n```shell\n## 变回windows\ngo env -w CGO_ENABLED=1 GOOS=windows GOARCH=amd64\n## linux\ngo env -w CGO_ENABLED=0 GOOS=linux GOARCH=amd64\ngo build .\n```\n\n## 5.4 Docker 镜像\n### 5.4.1 编写 Dockerfile\n在项目根目录下创建 `Dockerfile`\n```dockerfile\n# 使用 golang 的官方镜像作为基础镜像  \nFROM golang:latest  \n  \n# 设置工作目录  \nWORKDIR /app  \n  \n# 将代码复制到容器中的工作目录  \nCOPY . .  \n  \n# 构建 Go 语言程序  \nRUN go build -o CoBlogInterface .  \n  \n# 暴露需要监听的端口  \nEXPOSE 4001  \n  \n# 运行 Go 语言程序  \nCMD [\"./CoBlogInterface\"]\n```\n### 5.4.2 生成 Docker Image\n在 terminal打开,并输入：\n```bash\ndocker build -t co_blog_interface:1.0 .\n```\n\n![](http://137.175.84.209:88/article/cdb537ca-69aa-49b4-85ce-c0196de1be10.png)\n\n# 6 发布\n## 6.1 linux 发布\n## 6.2 Docker 发布\n安装 Docker\n拉取 ',1,10,'2023-12-21 20:26:15','http://137.175.84.209:88/article/deeae084-b5cf-423f-baab-8d1c93903626.png'),(60,17,1,'基于 Express 的喜敷网站后端','# 项目开发日志\n\n## 23.7.1\n\n### 一、创建项目\n \n在`github`上创建`WebsiteDevInterface`仓库，\n\n使用`git clone git@github.com:Undefined6608/WebsiteDevInterface.git`将其克隆到本地\n\n### 二、初始化项目\n\n使用`WebStorm`打开`WebsiteDevInterface`文件夹：\n\n打开控制台运行以下命令，进行初始化项目：\n\n```shell\nnpm init -y\n```\n\n创建项目所需文件，项目结构：\n\n![](http://118.31.43.239:81/image/examination/log/Snipaste_2023-07-01_10-44-13.png)\n\n### 三、导入/配置依赖\n\n> 使用的依赖/框架：\n>\n> `express`：项目框架\n>\n> `cors`：跨域第三方依赖\n>\n> `typescript`，`ts-node`：引入ts\n>\n> `nodemon`：热启动依赖，\n>\n> `log4js`：日志依赖\n>\n> `morgan`：控制台输出请求调用情况\n\n```shell\nnpm install express cors --save\nnpm install typescript ts-node nodemon --save-dev\nnpm install log4js\nnpm install morgan\n```\n\n编写`app.ts`：\n\n```ts\n// 引入express\nconst express = require(\'express\');\n// 引入cors\nconst cors = require(\'cors\');\n// 引入morgan\nconst morgan = require(\'morgan\');\n// 导入错误处理中间件\nconst errorHandler = require(\'./middleware/error-handler\');\n\n// 实例化express\nconst app = express();\n// 定义监听端口\nconst port = process.env.PORT || 4000;\n\n// 定义允许跨域请求的请求源地址列表\nconst allowedOrigins: string[] = [\n    \'http://192.168.126.1:3000\',\n    \'http://localhost:3000\'\n];\n\n// 添加中间件\n// 挂载cors实现跨域\napp.use(cors({\n    origin: (origin: string, callback) => {\n        // 检查请求的来源是否在允许的列表中\n        if (!origin || allowedOrigins.indexOf(origin) !== -1) {\n            callback(null, true);\n        } else {\n            callback(new Error(\'不允许的来源\'));\n        }\n    },\n    methods: [\'GET\', \'POST\', \'PUT\', \'DELETE\'], // 允许的请求方法\n}));\n//挂载morgan进行监听请求并输出\napp.use(morgan(\'dev\'));\n// 配置和挂载解析body请求体方法\napp.use(express.json());\napp.use(express.urlencoded({extended: false, limit: \'20mb\'}));\n// 挂载统一处理服务器错误的中间件\napp.use(errorHandler());\n\n// 添加路由和处理程序\napp.get(\'/\', (req, res) => {\n    res.send(\'Hello, world!\');\n});\n\n// 启动应用,开启端口监听\napp.listen(port, () => {\n    console.log(`Server is running on port ${port}`);\n});\n```\n\n编写`tsconfig.json`：\n\n```json\n{\n    \"compilerOptions\": {\n        \"lib\": [\"ES6\"],\n        \"module\": \"commonjs\",\n        \"moduleResolution\": \"node\",\n        \"outDir\": \"dist\",\n        \"target\": \"es6\",\n        \"sourceMap\": true,\n        \"allowSyntheticDefaultImports\": true\n    },\n    \"include\": [\n        \"app.ts\"\n    ]\n}\n```\n\n在`config`中创建`config.default.ts`文件:\n\n```ts\n// 导入log4js\nconst log4js = require(\"log4js\");\n// 配置log4js\nlog4js.configure({ // 复写配置信息\n    appenders: { // 配置存储日志格式\n        file: { // 配置存储类型\n            type: \'file\',// 配置存储类型为文件类型\n            filename: \'logs/app.log\', // 配置日志存储位置\n            maxLogSize: 10 * 1024 * 1024, // 配置日志最大为10 MB\n            backups: 3, // 超出最大大小，将保存备份，备份最大3个\n            compress: true, // 启用Gzip压缩备份文件\n            pattern: \'-yyyy-MM-dd.log\' // 保存日志写入时间戳\n        },\n        console: { // 配置控制台输出\n            type: \'console\', // 输出类型\n        },\n    },\n    categories: { // 定义不同日志分类\n        default: {appenders: [\'file\', \'console\'], level: \'info\'},// 配置默认分类\n    }\n});\n// 实例化log4js对象\nexport const logger = log4js.getLogger();\n```\n\n在`middleware`文件夹中创建`error-handler.ts`文件,用于处理服务器错误:\n\n```ts\nimport {logger} from \'../config/config.default\';\n\nmodule.exports = () => {\n    return (err, req, res, next) => {\n        logger.error(err);\n        res.status(500).json({\n            error: \"信息错误！\"\n        })\n    }\n}\n```\n\n### 四、创建路由\n\n在`router`文件夹中创建`index.ts`：\n\n```ts\n// 引入express\nconst express  = require(\'express\');\n// 创建router实例\nconst router = express.Router();\n\n// 挂载子路由\n\n// 抛出路由\nexport default router;\n```\n\n在`app.ts`中挂载路由，**注意：路由一般在`app.ts`的最下面，在端口监听上面**\n\n```ts\n// 添加路由和处理程序\napp.use(\'/api\', router);\n```\n\n#### 创建子路由\n\n在`router`文件夹中创建`publicRouter.ts`、`homeRouter.ts`、`aboutRouter.ts`、`productRouter.ts`、`informationRouter.ts`,`contactRouter.ts`\n\n将子路由挂载到主路由上，在`router/index.ts`中：\n\n```ts\n// 引入express\nconst express = require(\'express\');\n// 创建router实例\nconst router = express.Router();\n// 引入子路由\nimport publicRouter from \"./publicRouter\";\nimport homeRouter from \"./homeRouter\";\nimport aboutRouter from \"./aboutRouter\";\nimport productRouter from \"./productRouter\";\nimport informationRouter from \"./informationRouter\";\nimport contactRouter from \"./contactRouter\";\n\n/***********************挂载子路由************************/\nrouter.use(\'/public\', publicRouter);\nrouter.use(\'/home\', homeRouter);\nrouter.use(\'/about\', aboutRouter);\nrouter.use(\'/product\', productRouter);\nrouter.use(\'/information\', informationRouter);\nrouter.use(\'/contact\', contactRouter);\n\n/****************抛出路由***************/\nexport default router;\n```\n\n### 五、创建控制器\n\n在`controller`文件夹中创建`publicController.ts`、`homeController.ts`、`aboutController.ts`、`productController.ts`、`informatonController.ts`、`contactController.ts`\n\n### 六、创建本地数据库、泛型类、工具类\n\n在`config`文件夹中创建`PublicInterface.ts`文件\n\n在`model`文件夹中创建`DataBase.ts`文件\n\n在`utils`文件夹中创建`index.ts`文件\n\n### 七、开始编写后端项目\n\n> 因为使用的为ts，并且数据库为本地文件，那么：\n>\n> 编写顺序为：\n>\n> - 先根据所需数据类型进行定义数据接口，规范类型\n> - 定义所需数据，使用第一步规范好的类型作为泛型\n> - 定义域控制器方法，进行数据的增删改查，并返回响应数据\n> - 在路由中调取控制器方法，并规定网络接口地址\n\n#### I、定义返回数据格式\n\n在`publicInterface.ts`中编写：\n\n```ts\n// 成功响应值\nexport type SUCCESSType = 200;\n// 失败响应值\nexport type FAILType = 400;\n// 响应数据类型\nexport type ResultTypeType = {\n    // 响应值\n    code: SUCCESSType | FAILType,\n    // 响应信息\n    msg: string,\n    // 响应数据\n    data: any\n}\n```\n\n在`utils/index.ts`中编写：\n\n```ts\nimport {FAILType, ResultTypeType, SUCCESSType} from \"../config/PublicInterface\";\n\nexport const SUCCESS: SUCCESSType = 200;\nexport const FAIL: FAILType = 400;\n\n/**\n * 使用publicInterface里定义好的类型作为泛型\n * @param code 响应值\n * @param msg 响应信息\n * @param data 响应数据\n */\nexport const resultType = (code: SUCCESSType | FAILType, msg: string, data: any): ResultTypeType => {\n    return {\n        code: code,\n        msg: msg,\n        data: data\n    }\n}\n```\n\n#### II、编写公共组件数据\n\n##### 1、顶部logo\n\n在`publicInterface.ts`中：\n\n```ts\n// logo的类型\nexport type LogoDataType = string;\n```\n\n在`DataBase.ts`中：\n\n```ts\n// 网站logo\nconst logoData: LogoDataType = \"http://118.31.43.239:81/image/examination/project/logo.png\";\n```\n\n在`publicController.ts`中：\n\n```ts\n/**\n * 获取logo\n * @param req\n * @param res\n * @param next\n */\nexport const getLogo = (req, res, next) => {\n    try {\n        // 直接抛出logo地址\n        res.send(resultType(SUCCESS, \"获取成功！\", {\n            icon: logoData\n        }))\n    } catch (e) {\n        next(e);\n    }\n}\n```\n\n在`publicRouter.ts`中：\n\n```ts\n//获取logo\npublicRouter.get(\'/logo\', getLogo);\n```\n\n##### 2、顶部副标题\n\n在`publicInterface.ts`中：\n\n```ts\n// 副标题的类型\nexport type SubTitleType = string;\n```\n\n在`DataBase.ts`中：\n```ts\n// 网站副标题\nconst subTitle: SubTitleType = \"-喜于心 敷于形\";\n```\n\n在`publicController.ts`中：\n```ts\n/**\n * 获取副标题\n * @param req\n * @param res\n * @param next\n */\nexport const getSubTitle = (req, res, next) => {\n    try {\n        // 直接抛出logo地址\n        res.send(resultType(SUCCESS, \"获取成功！\", {\n            title: subTitle\n        }))\n    } catch (e) {\n        next(e);\n    }\n}\n```\n\n在`publicRouter.ts`中：\n```ts\n// 获取副标题\npublicRouter.get(\'/subTitle\',getSubTitle);\n```\n\n\n\n##### 3、导航列表\n\n在`publicInterface.ts`中：\n\n```ts\n// 导航按钮类型\nexport type NavItemType = {\n    id: string,\n    name: string,\n    subName: string,\n    url: string\n}\n```\n\n在`DataBase.ts`中：\n\n```ts\n// 导航按钮列表\nconst navList: Array<NavItemType> = [\n    // region\n    {\n        id: \'a\',\n        name: \"首页\",\n        subName: \"Home\",\n        url: \"/\"\n    }, {\n        id: \'b\',\n        name: \"了解喜敷\",\n        subName: \"ABOUT US\",\n        url: \"/about\"\n    }, {\n        id: \'c\',\n        name: \"产品中心\",\n        subName: \"PRODUCT CENTER\",\n        url: \"/product\"\n    }, {\n        id: \'d\',\n        name: \"喜敷咨询\",\n        subName: \"INFORMATION\",\n        url: \"/information\"\n    }, {\n        id: \'e\',\n        name: \"联系我们\",\n        subName: \"CONTACT US\",\n        url: \"/contact\"\n    }\n    // endregion\n]\n```\n\n在`publicController.ts`中：\n\n```ts\n/**\n * 获取导航条按钮列表\n * @param req\n * @param res\n * @param next\n */\nexport const getNavList = (req, res, next) => {\n    try {\n        // 直接抛出logo地址\n        res.send(resultType(SUCCESS, \"获取成功！\", {\n            list: navList\n        }))\n    } catch (e) {\n        next(e);\n    }\n}\n```\n\n在`publicRouter.ts`中：\n\n```ts\n// 获取头部跳转按钮列表\npublicRouter.get(\'/navList\',getNavList);\n```\n\n\n\n##### 4、页面头部图片\n\n在`publicInterface.ts`中：\n\n```ts\n// 页面图片类型\nexport type PageTopImg = {\n    id: string,\n    imgUrl: string,\n    alt: string\n}\n```\n\n在`DataBase.ts`中：\n\n> 让图片的id和页面id一致，用于查询图片\n\n```ts\n// 页面顶部图片列表\nconst pageTopList: Array<PageTopImg> = [\n    // region\n    {\n        id: \'a\',\n        imgUrl: \"http://118.31.43.239:81/image/examination/project/homeTop.jpg\",\n        alt: \"\"\n    }, {\n        id: \'b\',\n        imgUrl: \"http://118.31.43.239:81/image/examination/project/aboutTop.jpg\",\n        alt: \"\"\n    }, {\n        id: \'c\',\n        imgUrl: \"http://118.31.43.239:81/image/examination/project/productTop.jpg\",\n        alt: \"\"\n    }, {\n        id: \'d\',\n        imgUrl: \"http://118.31.43.239:81/image/examination/project/informationTop.jpg\",\n        alt: \"\"\n    }, {\n        id: \'e\',\n        imgUrl: \"http://118.31.43.239:81/image/examination/project/contactTop.jpg\",\n        alt: \"\"\n    },\n    // endregion\n]\n```\n\n在`publicController.ts`中：\n\n```ts\n/**\n * 获取每个页面头部图片\n * @param req\n * @param res\n * @param next\n */\nexport const getTopImg = (req, res, next) => {\n    try {\n        // 获取传入的参数\n        const query = req.query;\n        // 参数为空\n        if (!query.pageId) return res.send(resultType(FAIL, \"参数错误！\"));\n        for (let item of pageTopList) {\n            if (item.id === query.pageId) return res.send(resultType(SUCCESS, \"查询成功\", item));\n        }\n        res.send(resultType(FAIL,\"图片不存在！\"));\n        // 直接抛出logo地址\n        res.send(resultType(SUCCESS, \"获取成功！\", {\n            list: navList\n        }))\n    } catch (e) {\n        next(e);\n    }\n}\n```\n\n在`publicRouter.ts`中：\n\n```ts\n// 获取各个页面头部图片\npublicRouter.get(\'/topImg\',getTopImg);\n```\n\n\n\n##### 5、底部信息列表\n\n在`publicInterface.ts`中：\n\n```ts\n// 底部信息列表类型\nexport type BottomMsgListType = {\n    topLeft: {\n        one: string,\n        two: string,\n        three: string\n    },\n    topCenter: {\n        title: string,\n        phone: string,\n        email: string\n    },\n    topRight: {\n        QRCode: string,\n        tip: string,\n        end: string\n    },\n    bottom: {\n        one: string,\n        two: string\n    }\n}\n```\n\n在`DataBase.ts`中：\n\n```ts\n// 页面底部信息列表\nconst bottomMsgList: BottomMsgListType = {\n    topLeft: {\n        one: \"产品试用\",\n        two: \"产品试用   |  产品反馈\",\n        three: \"产品试用/反馈\"\n    },\n    topCenter: {\n        title: \"联系方式\",\n        phone: \"联系电话：020-31523984\",\n        email: \"联系邮箱：hi_xifu@163.com\"\n    },\n    topRight: {\n        QRCode: \"http://118.31.43.239:81/image/examination/project/QRCode.jpg\",\n        tip: \"扫码关注喜敷\",\n        end: \"参与免费领取试用活动\"\n    },\n    bottom: {\n        one: \"©2023 广州喜敷医美生物科技有限公司 版权所有\",\n        two: \"管理登录\"\n    }\n}\n```\n\n在`publicController.ts`中：\n\n```ts\n/**\n * 获取页面底部信息列表\n * @param req\n * @param res\n * @param next\n */\nexport const getBottomMsgList = (req, res, next) => {\n    try {\n        res.send(resultType(FAIL, \"查询成功！\", bottomMsgList));\n    } catch (e) {\n        next(e);\n    }\n}\n```\n\n在`publicRouter.ts`中：\n\n```ts\n// 获取页面底部信息列表\npublicRouter.get(\'/bottomMsgList\', getBottomMsgList);\n```\n\n## 23.7.3\n\n### 一、继续编写\n\n#### I、编写首页数据接口\n\n##### 1、编写首页第一个模块数据\n\n在`publicInterface.ts`中：\n\n```ts\n// 主页第一个模块数据类型\nexport type HomeOneType = {\n    title: string,\n    subTitle: string,\n    imgUrl: string,\n    context: string[],\n    btnMsg: string,\n    link: string\n};\n```\n\n在`DataBase.ts`中：\n\n```ts\n// 主页第一个模块数据\nconst HomeOneData: HomeOneType = {\n    title: \"喜敷-专业科学护肤品牌\",\n    subTitle: \"XIFU- professional scientific skin care brand\",\n    imgUrl: \"http://118.31.43.239:81/image/examination/project/homeOneImg.jpg\",\n    context: [\n        \"传统护肤品配方，更多的是迎合大众速效的心理或追求产品营销卖点为目的，过于追求产品的使用效果，而降低产品本身对安全性的要求。常见于过度添加功效性成分甚至违规添加激素辅助等，极大增加了护肤使用造成的不良反应风险系数。\",\n        \"护肤品领域，历经多个时代变迁，伴随着各种技术的更新和成熟的背后是吸取了无数的案例验证和教训！而今我们面对未来，护肤需要更加科学、更加安全与可靠的方式进行。\",\n        \"喜敷-专业科学护肤品牌   专注问题肌肤的护理探研-引领专业成就科技之美 -打造护肤新势力\",\n        \"XIFU喜敷® 源自于台湾，依托台湾皮肤科专家游历东南亚国家积累十余年皮肤外用药研发和生产的经验，结合亚洲人皮肤特点，对研发产品的功能定位、功效、核心成份、核心技术严格把关，不断对产品配方工艺进行优化和改进，开发出效果、安全、肤感多兼顾的产品。\"\n    ],\n    btnMsg: \"查看更多\",\n    link: \"/about\"\n}\n```\n\n在`homeController.ts`中：\n\n```ts\n// 首页第一个模块数据控制器\nexport const getHomeOne = (req, res, next) => {\n    try {\n        // 直接抛出数据\n        res.send(resultType(SUCCESS, \"获取成功！\", HomeOneData));\n    } catch (e) {\n        next(e);\n    }\n};\n```\n\n在`homeRouter.ts`中：\n\n```ts\n//首页第一个模块数据路由\nhomeRouter.get(\'/homeOne\', getHomeOne);\n```\n\n##### 2、编写首页图片列表数据\n\n在`publicInterface.ts`中：\n\n```ts\n// 主页图片列表类型\nexport type HomeImgType = {\n    imgUrl: string[]\n};\n```\n\n在`DataBase.ts`中：\n\n```ts\n// 主页上的图片集合\nconst HomeImgList: HomeImgType = {\n    imgUrl:[\n        \"http://118.31.43.239:81/image/examination/project/HomeImg01.jpg\",\n        \"http://118.31.43.239:81/image/examination/project/homeImg02.jpg\"\n    ]\n}\n```\n\n在`homeController.ts`中：\n\n```ts\n// 获取首页图片集合\nexport const getHomeImgList = (req, res, next) => {\n    try {\n        // 直接抛出图片数据\n        res.send(resultType(SUCCESS, \"获取成功！\", HomeImgList));\n    } catch (e) {\n        next(e);\n    }\n};\n```\n\n在`homeRouter.ts`中：\n\n```ts\n// 首页图片集合\nhomeRouter.get(\'/getHomeImgList\',getHomeImgList);\n```\n\n##### 3、编写首页第二个模块数据\n\n在`publicInterface.ts`中：\n\n```ts\n// 主页第二个模块数据类型\nexport type HomeTwoType = {\n    title: string,\n    subTitle: string,\n    type:Array<{\n        id:string,\n        name:string\n    }>,\n    productList:Array<{\n        id:string,\n        typeId:string,\n        itemImg:string,\n        name:string\n    }>\n}\n```\n\n在`DataBase.ts`中：\n\n```ts\n// 主页第二个模块数据\nconst HomeTwoData: HomeTwoType = {\n    title: \"产品中心\",\n    subTitle: \"PRODUCT CENTER\",\n    type: [\n        {\n            id:\'p1\',\n            name:\"喜敷 | 成人护理系列\"\n        }\n    ],\n    productList: [\n        {\n            id: crypto.randomUUID(),\n            typeId:\'p1\',\n            itemImg: \"http://118.31.43.239:81/image/examination/project/product1.jpg\",\n            name: \"XIFU 红豚护理软膏\"\n        }, {\n            id: crypto.randomUUID(),\n            typeId:\'p1\',\n            itemImg: \"http://118.31.43.239:81/image/examination/project/product2.jpg\",\n            name: \"XIFU喜敷 水杨酸焕颜面膜 100g\"\n        }, {\n            id: crypto.randomUUID(),\n            typeId:\'p1\',\n            itemImg: \"http://118.31.43.239:81/image/examination/project/product3.jpg\",\n            name: \"XIFU喜敷 氨基酸洁面慕斯 100ml\"\n        }, {\n            id: crypto.randomUUID(),\n            typeId:\'p1\',\n            itemImg: \"http://118.31.43.239:81/image/examination/project/product4.jpg\",\n            name: \"XIFU医用冷敷贴膜5片/盒\"\n        }, {\n            id: crypto.randomUUID(),\n            typeId:\'p1\',\n            itemImg: \"http://118.31.43.239:81/image/examination/project/product5.jpg\",\n            name: \"XIFU 喜敷 医用多肽水凝胶 100ml\"\n        }, {\n            id: crypto.randomUUID(),\n            typeId:\'p1\',\n            itemImg: \"http://118.31.43.239:81/image/examination/project/product6.jpg\",\n            name: \"XIFU 喜敷 清痘冷敷凝胶  15g\"\n        }\n    ]\n}\n```\n\n在`homeController.ts`中：\n\n```ts\n// 首页第二个模块数据控制器\nexport const getHomeTwo = (req, res, next) => {\n    try {\n        // 直接抛出数据\n        res.send(resultType(SUCCESS, \"获取成功！\", HomeTwoData));\n    } catch (e) {\n        next(e);\n    }\n};\n```\n\n在`homeRouter.ts`中：\n\n```ts\n//首页第二个模块数据路由\nhomeRouter.get(\'/homeOne\', getHomeTwo);\n```\n\n##### 4、编写首页第三个模块数据\n\n在`publicInterface.ts`中：\n\n```ts\n// 主页第三个模块数据类型\nexport type HomeThreeType = {\n    oneTitle: string,\n    oneSubTitle: string,\n    twoTitle: string,\n    twoSubTitle: string\n};\n```\n\n在`DataBase.ts`中：\n\n```ts\n// 主页第二个模块数据\nconst HomeThreeData: HomeThreeType = {\n    oneTitle: \"XIFU  喜敷\",\n    oneSubTitle: \"----- 源自台湾知名化工专家深耕多年的精心之作 -----\",\n    twoTitle: \"【专业科学护肤品牌】\",\n    twoSubTitle: \"专注问题肌肤的护理探研  |  引领专业成就科技之美  |  打造护肤新势力\"\n}\n```\n\n在`homeController.ts`中：\n\n```ts\n// 首页第三个模块数据控制器\nexport const getHomeThree = (req, res, next) => {\n    try {\n        // 直接抛出数据\n        res.send(resultType(SUCCESS, \"获取成功！\", HomeThreeData));\n    } catch (e) {\n        next(e);\n    }\n};\n```\n\n在`homeRouter.ts`中：\n\n```ts\n//首页第三个模块数据路由\nhomeRouter.get(\'/homeThree\', getHomeThree);\n```\n\n##### 5、编写首页第四个模块数据\n\n在`publicInterface.ts`中：\n\n```ts\n// 主页第四个模块数据类型\nexport type HomeFourType = {\n    title: string,\n    subTitle: string,\n    list: Array<{\n        id: string\n        icon: string,\n        mtd: string,\n        val: string\n    }>\n};\n```\n\n在`DataBase.ts`中：\n\n```ts\n// 主页第四个模块数据\nconst HomeFourData: HomeFourType = {\n    title: \"联系我们\",\n    subTitle: \"CONTACT US\",\n    list: [\n        {\n            id: crypto.randomUUID(),\n            icon: \"http://118.31.43.239:81/image/examination/project/contact1.jpg\",\n            mtd: \"联系邮箱\",\n            val: \"hi_xifu@163.com\"\n        }, {\n            id: crypto.randomUUID(),\n            icon: \"http://118.31.43.239:81/image/examination/project/contact2.jpg\",\n            mtd: \"联系电话\",\n            val: \"020-31523984\"\n        }, {\n            id: crypto.randomUUID(),\n            icon: \"http://118.31.43.239:81/image/examination/project/contact3.jpg\",\n            mtd: \"联系地址\",\n            val: \"广东省广州市白云区石厦路榕溪工业大街新创展大厦605房\"\n        },\n    ]\n};\n```\n\n在`homeController.ts`中：\n\n```ts\n// 引入工具方法\nimport {resultType, SUCCESS} from \"../utils\";\n// 引入数据源\nimport {HomeFourData, HomeImgList, HomeOneData, HomeThreeData, HomeTwoData, logoData} from \"../model/DataBase\";\n// 引入日志输出工具\nimport {logger} from \"../config/config.default\";\n\n/***************定义控制器方法*******************/\n// 首页第一个模块数据控制器\nexport const getHomeOne = (req, res, next) => {\n    try {\n        // 直接抛出数据\n        res.send(resultType(SUCCESS, \"获取成功！\", HomeOneData));\n    } catch (e) {\n        next(e);\n    }\n};\n// 获取首页图片集合\nexport const getHomeImgList = (req, res, next) => {\n    try {\n        // 直接抛出图片数据\n        res.send(resultType(SUCCESS, \"获取成功！\", HomeImgList));\n    } catch (e) {\n        next(e);\n    }\n};\n// 首页第二个模块数据控制器\nexport const getHomeTwo = (req, res, next) => {\n    try {\n        // 直接抛出数据\n        res.send(resultType(SUCCESS, \"获取成功！\", HomeTwoData));\n    } catch (e) {\n        next(e);\n    }\n};\n// 首页第三个模块数据控制器\nexport const getHomeThree = (req, res, next) => {\n    try {\n        // 直接抛出数据\n        res.send(resultType(SUCCESS, \"获取成功！\", HomeThreeData));\n    } catch (e) {\n        next(e);\n    }\n};\n// 首页第四个模块数据控制器\nexport const getHomeFour = (req, res, next) => {\n    try {\n        // 直接抛出数据\n        res.send(resultType(SUCCESS, \"获取成功！\", HomeFourData));\n    } catch (e) {\n        next(e);\n    }\n};	\n```\n\n在`homeRouter.ts`中：\n\n```ts\n//首页第四个模块数据路由\nhomeRouter.get(\'/homeFour\', getHomeFour);\n```\n\n#### II、编写产品中心数据接口\n\n在`DataBase.ts`中：\n\n```ts\n// 产品页面数据\nconst ProductListData: HomeTwoType = {\n    title: \"产品中心\",\n    subTitle: \"PRODUCT CENTER\",\n    type: [\n        {\n            id: \'p1\',\n            name: \"喜敷 | 成人护理系列\"\n        }, {\n            id: \'p2\',\n            name: \"喜敷 | 婴幼儿系列\"\n        }, {\n            id: \'p3\',\n            name: \"沐儿洁灵 | 儿童洗护系列\"\n        },\n    ],\n    productList: [\n        {\n            id: crypto.randomUUID(),\n            typeId: \'p1\',\n            itemImg: \"http://118.31.43.239:81/image/examination/project/product1.jpg\",\n            name: \"XIFU 红豚护理软膏\"\n        }, {\n            id: crypto.randomUUID(),\n            typeId: \'p1\',\n            itemImg: \"http://118.31.43.239:81/image/examination/project/product2.jpg\",\n            name: \"XIFU喜敷 水杨酸焕颜面膜 100g\"\n        }, {\n            id: crypto.randomUUID(),\n            typeId: \'p1\',\n            itemImg: \"http://118.31.43.239:81/image/examination/project/product3.jpg\",\n            name: \"XIFU喜敷 氨基酸洁面慕斯 100ml\"\n        }\n    ]\n};\n```\n\n在`productController.ts`中：\n\n```ts\n// 引入工具方法\nimport {resultType, SUCCESS} from \"../utils\";\n// 引入数据源\nimport {ProductListData} from \"../model/DataBase\";\n// 引入日志输出工具\nimport {logger} from \"../config/config.default\";\n\n/***************定义控制器方法*******************/\n// 产品列表\nexport const productList = (req, res, next) => {\n    try {\n        // 直接抛出数据\n        res.send(resultType(SUCCESS, \"获取成功！\", ProductListData));\n    } catch (e) {\n        next(e);\n    }\n};\n```\n\n在`productRouter.ts`中：\n\n```ts\n// 引入express\nconst express = require(\'express\');\n// 创建router实例\nconst productRouter = express.Router();\n// 引入控制器\nimport {productList} from \"../controller/productController\";\n\n/***************定义路由*****************/\nproductRouter.get(\'/productList\', productList);\n\n/****************抛出路由***************/\nexport default productRouter;\n```\n\n## 23.7.4\n\n### 一、继续编写\n\n#### I、编写关于喜敷页面接口\n\n在`publicInterface.ts`中：\n\n```ts\n// 关于页面数据类型\nexport type AboutDataType = Array<{\n    id: string,\n    title: string,\n    subTitle: string,\n    mainImg: string,\n    bgImg: string,\n    context: Array<{\n        id: string,\n        msg: string\n    }>\n}>;\n```\n\n在`DataBase.ts`中：\n\n```ts\n// 关于页面的数据\nconst AboutListData: AboutDataType = [\n    {\n        id: crypto.randomUUID(),\n        title: \"关于我们\",\n        subTitle: \"ABOUT US\",\n        mainImg: \"http://118.31.43.239:81/image/examination/project/about01.jpg\",\n        bgImg: \"http://118.31.43.239:81/image/examination/project/bgImg01.jpg\",\n        context: [\n            {\n                id: crypto.randomUUID(),\n                msg: \"XIFU喜敷®是源自台湾的精品科学护肤品牌，创始人Jeff是一位突破性的皮肤科专家和配方师，曾在医美行业从事多年，深悉各类皮肤症状与相关药物成分的相辅性，而后游历于东南亚国家十余年积累了深厚的皮肤外用药的研发和生产经验。\",\n            }, {\n                id: crypto.randomUUID(),\n                msg: \"在各种类别的护肤品应用中，Jeff觉得应当遵循科学的护理方式，理性护肤。\"\n            }, {\n                id: crypto.randomUUID(),\n                msg: \"喜敷系列产品研发过程中，正是秉承Jeff先生这种“科学护肤”的理念，依托其多年的皮肤外用药研发和生产的经验，结合亚洲人皮肤特点，对研发产品的功能定位、核心成份、核心技术严格把关，不断对产品配方和工艺进行优化和改进，打造每一款产品最好的功效。\",\n            }, {\n                id: crypto.randomUUID(),\n                msg: \"使用安全、有效的产品，是辅助皮肤护理的唯一科学选项！——Jeff\"\n            },\n        ]\n    }, {\n        id: crypto.randomUUID(),\n        title: \"发展历程\",\n        subTitle: \"COURSE\",\n        mainImg: \"http://118.31.43.239:81/image/examination/project/about02.jpg\",\n        bgImg: \"http://118.31.43.239:81/image/examination/project/bgImg01.jpg\",\n        context: [\n            {\n                id: crypto.randomUUID(),\n                msg: \"企业理念：诚信，创新，专业，务实。\",\n            }, {\n                id: crypto.randomUUID(),\n                msg: \"企业精神：敢于担当，勇于创新，与时俱进。\",\n            }, {\n                id: crypto.randomUUID(),\n                msg: \"企业价值观：追求不凡，创造完美。\",\n            }, {\n                id: crypto.randomUUID(),\n                msg: \"企业愿景：让每个人更快乐，更美丽\"\n            },\n        ]\n    },\n];\n```\n\n在`aboutController.ts`中：\n\n```ts\n// 引入工具方法\nimport {resultType, SUCCESS} from \"../utils\";\n// 引入数据源\nimport {AboutListData, logoData} from \"../model/DataBase\";\n// 引入日志输出工具\nimport {logger} from \"../config/config.default\";\n\n/***************定义控制器方法*******************/\nexport const getAboutList = (req, res, next) => {\n    try {\n        res.send(resultType(SUCCESS, \"获取成功！\", {\n            list: AboutListData\n        }))\n    } catch (e) {\n        next(e);\n    }\n}\n```\n\n在`aboutRouter.ts`中：\n\n```ts\n// 引入express\nconst express = require(\'express\');\n// 创建router实例\nconst aboutRouter = express.Router();\n// 引入控制器\nimport {getAboutList} from \"../controller/aboutController\";\n\n/***************定义路由*****************/\naboutRouter.get(\'/getAboutList\', getAboutList);\n/****************抛出路由***************/\nexport default aboutRouter;\n```\n\n#### II、编写联系我们页面接口\n\n在`publicInterface.ts`中：\n\n```ts\n// 联系我们表单数据类型\nexport type ContactDataType = {\n    id: string,\n    name: string,\n    context: string,\n    phone: string,\n    email: string\n}\n```\n\n在`DataBase.ts`中：\n\n```ts\n// 联系我们页面表单集合\nconst ContactFormList: Array<ContactDataType> = [];\n```\n\n在`contactController.ts`中：\n\n```ts\n// 引入工具方法\nimport {FAIL, resultType, SUCCESS} from \"../utils\";\n// 引入数据源\nimport {ContactFormList, logoData} from \"../model/DataBase\";\n// 引入日志输出工具\nimport {logger} from \"../config/config.default\";\nimport * as crypto from \"crypto\";\n\n/***************定义控制器方法*******************/\nexport const pushForm = (req, res, next) => {\n    try {\n        const body = req.body;\n        if (!body.name || !body.email || !body.phone || !body.context) return res.send(resultType(FAIL, \"参数错误!\"));\n        ContactFormList.push({\n            id: crypto.randomUUID(),\n            name: body.name,\n            email: body.email,\n            phone: body.phone,\n            context: body.context\n        });\n        res.send(resultType(SUCCESS, \"保存！\"));\n    } catch (e) {\n        next(e);\n    }\n}\n```\n\n在`contactRouter.ts`中：\n\n```ts\n// 引入express\nconst express = require(\'express\');\n// 创建router实例\nconst contactRouter = express.Router();\n// 引入控制器\nimport {pushForm} from \"../controller/contactController\";\n\n/***************定义路由*****************/\ncontactRouter.post(\'/pushForm\', pushForm);\n\n/****************抛出路由***************/\nexport default contactRouter;\n```\n\n#### III、编写喜敷新闻资讯接口\n\n在`publicInterface.ts`中：\n\n```ts\n// 喜敷资讯数据类型\nexport type InformationDataType = {\n    title: string,\n    subTitle: string,\n    list: Array<{\n        id: string,\n        month: string,\n        day: string,\n        title: string,\n        context: string\n    }>\n};\n```\n\n在`DataBase.ts`中：\n\n```ts\n// 喜敷资讯数据\nconst InformationData: InformationDataType = {\n    title: \"喜敷资讯\",\n    subTitle: \"INFORMATION\",\n    list: [\n        {\n            id: crypto.randomUUID(),\n            month:\"2019/12\",\n            day:\"21\",\n            title: \"学术论坛 百花齐放——“第二届粤东皮肤科高峰论坛”\",\n            context: \"2019年12月21日，“第二届粤东皮肤科高峰论坛”暨广东省继续教育项目《儿童皮肤科诊疗新进展学习班》，在汕头市盛大召开。本次学术活动邀请了多位国内知名的皮肤专家莅临汕头授课，交流皮肤科领域的最新诊疗技术、最新科研动态、最新临床指南、最新药...\"\n        }, {\n            id: crypto.randomUUID(),\n            month:\"2019/11\",\n            day:\"30\",\n            title: \"中西医结合会议丨关于喜敷儿科产品近期实际应用与临床反馈结果展述\",\n            context: \"由广东省中医药学会皮肤病专业委员会、广东省中西医结合学会皮肤性病专业委员会、广东省中医药学研究促进会皮肤性病学分会主办的：“2019年广东省中医中西医结合皮肤性病学术会议-第十五届全国中医中西医结合皮肤性病研究进展学习班”，于2019年11...\"\n        }, {\n            id: crypto.randomUUID(),\n            month:\"2019/11\",\n            day:\"29\",\n            title: \"深圳健协皮肤科会议 | 如何科学护肤，新征途，喜敷与您携手共进\",\n            context: \"为了进一步推动慢性病皮肤病的管理，由深圳健康管理协会皮肤科专委会承办的“皮肤科医生如何做好慢性皮肤病管理”会议，于...\"\n        },\n    ]\n};\n```\n\n在`informationController.ts`中：\n\n```ts\n// 引入工具方法\nimport {resultType, SUCCESS} from \"../utils\";\n// 引入数据源\nimport {InformationData, logoData} from \"../model/DataBase\";\n// 引入日志输出工具\nimport {logger} from \"../config/config.default\";\n\n/***************定义控制器方法*******************/\nexport const getInformationData = (req, res, next) => {\n    try {\n        res.send(resultType(SUCCESS, \"获取成功！\", InformationData));\n    } catch (e) {\n        next(e);\n    }\n}\n```\n\n在`informationRouter.ts`中：\n\n```ts\n// 引入express\nconst express = require(\'express\');\n// 创建router实例\nconst informationRouter = express.Router();\n// 引入控制器\nimport {getInformationData} from \"../controller/informationController\";\n\n/***************定义路由*****************/\ninformationRouter.get(\'/getInformationData\', getInformationData);\n\n/****************抛出路由***************/\nexport default informationRouter;\n```\n\n',1,1,'2024-02-27 17:30:24','http://118.31.43.239:88/article/c60b03e2-1882-42b7-a3fe-ba1a699f1259.png');
/*!40000 ALTER TABLE `article` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `article_comments`
--

DROP TABLE IF EXISTS `article_comments`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `article_comments` (
  `id` int(10) unsigned NOT NULL AUTO_INCREMENT,
  `article_id` int(10) unsigned NOT NULL,
  `user_id` int(10) unsigned NOT NULL,
  `context` varchar(255) NOT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=3 DEFAULT CHARSET=utf8mb4;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `article_comments`
--

LOCK TABLES `article_comments` WRITE;
/*!40000 ALTER TABLE `article_comments` DISABLE KEYS */;
/*!40000 ALTER TABLE `article_comments` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `article_type`
--

DROP TABLE IF EXISTS `article_type`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `article_type` (
  `id` int(10) unsigned NOT NULL AUTO_INCREMENT,
  `root_id` int(10) unsigned NOT NULL,
  `type_name` varchar(191) NOT NULL,
  `type_visible` tinyint(1) NOT NULL DEFAULT '1',
  `order` tinyint(3) unsigned NOT NULL,
  `picture` longtext NOT NULL,
  `add_status` tinyint(1) NOT NULL DEFAULT '1',
  PRIMARY KEY (`id`),
  UNIQUE KEY `type_name` (`type_name`),
  UNIQUE KEY `order` (`order`)
) ENGINE=InnoDB AUTO_INCREMENT=75 DEFAULT CHARSET=utf8mb4;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `article_type`
--

LOCK TABLES `article_type` WRITE;
/*!40000 ALTER TABLE `article_type` DISABLE KEYS */;
INSERT INTO `article_type` VALUES (1,0,'Java',1,8,'http://137.175.84.209:81/image/co-blog/icon/java.png',1),(2,0,'JavaScript',1,3,'http://137.175.84.209:81/image/co-blog/icon/js.png',0),(3,0,'HTML5',1,1,'http://137.175.84.209:81/image/co-blog/icon/html.png',1),(4,0,'CSS',1,2,'http://137.175.84.209:81/image/co-blog/icon/css.png',0),(5,2,'jQuery',1,20,'http://137.175.84.209:81/image/co-blog/icon/jquery.png',1),(6,0,'Python',1,10,'http://137.175.84.209:81/image/co-blog/icon/python.png',1),(7,0,'C',1,11,'http://137.175.84.209:81/image/co-blog/icon/c.png',1),(8,0,'C++',1,12,'http://137.175.84.209:81/image/co-blog/icon/c++.png',1),(9,0,'C#',1,13,'http://137.175.84.209:81/image/co-blog/icon/c-sharp.png',1),(10,0,'SpringBoot',1,9,'http://137.175.84.209:81/image/co-blog/icon/spring-boot.png',1),(11,0,'BootStrap',1,4,'http://137.175.84.209:81/image/co-blog/icon/bootstrap.png',1),(12,0,'React',1,7,'http://137.175.84.209:81/image/co-blog/icon/react.png',1),(13,0,'Vue',1,6,'http://137.175.84.209:81/image/co-blog/icon/vue.png',1),(14,0,'MySQL',1,14,'http://137.175.84.209:81/image/co-blog/icon/mysql.png',1),(15,4,'Less',1,21,'http://137.175.84.209:81/image/co-blog/icon/less.png',1),(16,4,'Sass',1,16,'http://137.175.84.209:81/image/co-blog/icon/sass.png',1),(17,0,'Node.js',1,17,'http://137.175.84.209:81/image/co-blog/icon/node.png',1),(18,0,'NetworkSecurity',1,18,'http://137.175.84.209:81/image/co-blog/icon/network-security.png',0),(19,18,'NetworkTools',1,19,'http://137.175.84.209:81/image/co-blog/icon/net-tool.png',1),(20,2,'JSBase',1,5,'http://137.175.84.209:81/image/co-blog/icon/js.png',1),(21,4,'CSSBase',1,15,'http://137.175.84.209:81/image/co-blog/icon/css.png',1),(22,0,'TypeScript',1,22,'http://137.175.84.209:81/image/co-blog/icon/typescript.png',1),(23,0,'Vite',1,23,'http://137.175.84.209:81/image/co-blog/icon/vite.png',1),(24,0,'Webpack',1,24,'http://137.175.84.209:81/image/co-blog/icon/webpack.png',1),(25,0,'Others',1,100,'http://137.175.84.209:81/image/co-blog/icon/others.png',1),(26,0,'Docker',1,25,'http://137.175.84.209:81/image/co-blog/icon/docker.png',1),(27,0,'Golang',1,26,'http://137.175.84.209:81/image/co-blog/icon/golang.png',1),(28,0,'UniApp',1,27,'http://137.175.84.209:81/image/co-blog/icon/uniapp.png',1);
/*!40000 ALTER TABLE `article_type` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `feed_back`
--

DROP TABLE IF EXISTS `feed_back`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `feed_back` (
  `id` int(10) unsigned NOT NULL AUTO_INCREMENT,
  `user_id` int(10) unsigned NOT NULL,
  `context` varchar(255) NOT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `feed_back`
--

LOCK TABLES `feed_back` WRITE;
/*!40000 ALTER TABLE `feed_back` DISABLE KEYS */;
/*!40000 ALTER TABLE `feed_back` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `sys_user`
--

DROP TABLE IF EXISTS `sys_user`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `sys_user` (
  `uid` int(10) unsigned NOT NULL AUTO_INCREMENT,
  `user_name` varchar(255) NOT NULL,
  `phone` varchar(11) NOT NULL,
  `head_sculpture` varchar(191) DEFAULT 'http://39.101.72.168:81/image/icon.jpg',
  `password` text NOT NULL,
  `email` varchar(191) NOT NULL,
  `available` tinyint(1) NOT NULL DEFAULT '0',
  `limit` tinyint(3) unsigned NOT NULL DEFAULT '2',
  `integral` int(10) unsigned NOT NULL DEFAULT '0',
  `member` tinyint(3) unsigned NOT NULL DEFAULT '2',
  `create_time` datetime DEFAULT NULL,
  `update_time` datetime DEFAULT NULL,
  `uuid` varchar(36) NOT NULL,
  PRIMARY KEY (`uid`),
  UNIQUE KEY `phone` (`phone`),
  UNIQUE KEY `email` (`email`)
) ENGINE=InnoDB AUTO_INCREMENT=4 DEFAULT CHARSET=utf8mb4;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `sys_user`
--

LOCK TABLES `sys_user` WRITE;
/*!40000 ALTER TABLE `sys_user` DISABLE KEYS */;
INSERT INTO `sys_user` VALUES (1,'Undefined6608','15506531157','http://137.175.84.209:81/image/co-blog/avatar/210b02b8-130b-4f22-a1c3-0eaa153aad53.png','$2a$10$P9fc77ve7YogVHunEz6HXu.Ue9Fk3t/7aoUTc39xdtPwn1Ode1bry','15506531157@163.com',0,0,10000,0,'2023-12-21 18:52:20','2023-12-21 18:52:20','f150b328-adba-446a-83a2-b6ed4a7dc8e0'),(3,'test01','17865937390','http://137.175.84.209:81/image/co-blog/avatar/0e1ec1ae-605c-49ad-a330-f86b1ea3bac4.jpg','$2a$10$6ppBlWLWhKwXSEuewQwT2uMQLVyaaEetFFhFCS/Z3f4cSOOhypk5G','19953008089@163.com',0,2,0,2,'2023-11-29 17:15:59','2023-11-29 17:15:59','37e78b7b-c441-43a4-8f03-73c972baec2e');
/*!40000 ALTER TABLE `sys_user` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Dumping events for database 'co_blog'
--

--
-- Dumping routines for database 'co_blog'
--
/*!40103 SET TIME_ZONE=@OLD_TIME_ZONE */;

/*!40101 SET SQL_MODE=@OLD_SQL_MODE */;
/*!40014 SET FOREIGN_KEY_CHECKS=@OLD_FOREIGN_KEY_CHECKS */;
/*!40014 SET UNIQUE_CHECKS=@OLD_UNIQUE_CHECKS */;
/*!40101 SET CHARACTER_SET_CLIENT=@OLD_CHARACTER_SET_CLIENT */;
/*!40101 SET CHARACTER_SET_RESULTS=@OLD_CHARACTER_SET_RESULTS */;
/*!40101 SET COLLATION_CONNECTION=@OLD_COLLATION_CONNECTION */;
/*!40111 SET SQL_NOTES=@OLD_SQL_NOTES */;

-- Dump completed on 2024-02-27 17:40:31
